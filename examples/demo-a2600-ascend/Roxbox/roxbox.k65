/*
 * Optimize:
 * - Speed, size, ram: box_line var re-use, parameter passing, duplicate instructions in both cases
 * - RAM, speed, Size: box_frameBase needed?
 * - Size: Remove sine_20 and replace with sine_40, a>>
 * - Size: Combine box_bla_init funcs
 */
[
	STATE_BOX_ROT2 = 0,
	STATE_BOX_CUBE = 1,
	STATE_BOX_BIG = 2,
	STATE_BOX_ROT4 = 3,
	STATE_BOX_END = 4
]
[
	STATE_BOX_DURATION = 255
]
[
	BOX_BUFHEIGHT = 80
]

var box_lineCount=0x84, box_s ?;
var box_frameBase ?, box_cur_sin ?;
var box_sort[4] ?, box_min ?, box_minIndex ?;
var box_a ?, box_b ?, box_c ?, box_d ?;
var box_xStart ?, box_xEnd ?, box_yStart ?, box_yEnd ?;
var box_xStart2 ?, box_xEnd2 ?, box_yStart2 ?, box_yEnd2 ?;
var	box_dx ?, box_dy ?, box_error ?;
var box_byteCode[BOX_BUFHEIGHT] ?;
var box_varend ?;


/* Waste x scanlines.
 */
func box_waste {
	{wsync x--}!=
}


/* Empty, dummy display kernel
 */
func box_sl12 {
}


/* Draw a box "line".
 * IN: xStart, xEnd, yStart, yEnd. yEnd must be > yStart
 * Trashes: box_x/yStart/End
 */
func box_line {
	a=box_yEnd c+ a-box_yStart =={goto .skip} box_dy=a
	a=box_xEnd c+ a-box_xStart <goto .negativeX box_dx=a
	a?box_dy <goto .dyGreaterThanDx
	// dy < dx: x is fast direction
	a>> box_error=a
	box_xEnd++ y=box_yStart x=box_xStart {
		a=box_error c+ a-box_dy <{ box_byteCode,y=x y++ a+box_dx }
		box_error=a
		x++ x?box_xEnd
	}!=
	==goto .lastStore

.dyGreaterThanDx:
	// dx < dy: y is fast direction
	a>> box_error=a
	box_yEnd++ y=box_yStart x=box_xStart {
		box_byteCode,y=x
		a=box_error c+ a-box_dx <{ x++ a+box_dy }
		box_error=a
		y++ y?box_yEnd
	}!=
	==goto .skip

	// xEnd < xStart
.negativeX:
	a=box_xStart c+ a-box_xEnd box_dx=a
	a?box_dy <goto .dyGreaterThanDx2
	// dy < dx: x is fast direction
	a>> box_error=a
	box_xEnd-- y=box_yStart x=box_xStart {
		a=box_error c+ a-box_dy <{ box_byteCode,y=x y++ a+box_dx }
		box_error=a
		x-- x?box_xEnd
	}!=
.lastStore:
	box_byteCode,y=x
	==goto .skip

.dyGreaterThanDx2:
	// dx < dy: y is fast direction
	a>> box_error=a
	box_yEnd++ y=box_yStart x=box_xStart {
		box_byteCode,y=x
		a=box_error c+ a-box_dx <{ x-- a+box_dy }
		box_error=a
		y++ y?box_yEnd
	}!=
	
.skip:
}


/* Clear frame buffer
 */
func box_clear {
	x=[BOX_BUFHEIGHT-1] a=0 {
		box_byteCode,x=a
		x--
	}>=0
}


/* Box kernel
 */
func box_display {
	// Set size of buffer to display according to state
	wsync
	a=demoState a&1 =={
		// Fade in
		a=numFrame
	} else {
		// Fade out
		a=[STATE_BOX_DURATION] c+ a-numFrame
	}
	a|1	a?[BOX_BUFHEIGHT/2] >={a=[BOX_BUFHEIGHT/2]}
	box_lineCount=a
	// Calc margin from top
	wsync
	tmp=a a=[BOX_BUFHEIGHT/2+1] c+ a-tmp a+6 x=a
	// Calc frame fade color
	wsync
	a=tmp a>> a?0x0e >={a=0x0e} box_cur_sin=a
	
	box_waste
	wsync COLUBK=a=box_cur_sin wsync COLUBK=a=0
	x=6 box_waste

	tmp=tmp2=a=0
	// Prepare stack pointer
	box_s=x=s s=x=&<box_byteCode-1

	// Display 0, reposition 1
	// Enter with a=color, tmp=width
.display0:
	// New line: set color, enable/disable objects, set PF
	wsync hmove COLUPF=a
	GRP1=ENAM1=a=0 GRP0=y=0xff
	x=tmp PF1=a=box_PF1,x PF2=a=box_PF2,x
	ENAM0=y
	// get data
	a?? x=a a&63 tmp=a y=a
	// Set color and HM
	tmp2=COLUP1=a=box_colors,x
	HMP1=a=box_leftHm,y HMM1=a=box_rightHm,y
	// Get delays
	x=box_leftDelay,y
	a=box_rightDelay,y y=a
	*7 a=tmp2
	// re-position
	nocross{x--}!= RESP1=a nocross{y--}!= RESM1=a

	// Display 1, reposition 0
.display1:
	// New line: set color, enable/disable objects, set PF
	wsync hmove COLUPF=a
	GRP0=ENAM0=a=0 GRP1=y=0xff
	x=tmp PF1=a=box_PF1,x PF2=a=box_PF2,x
	ENAM1=y
	// get data
	a?? x=a a&63 tmp=a y=a
	// Set color and HM
	tmp2=COLUP0=a=box_colors,x
	HMP0=a=box_leftHm,y HMM0=a=box_rightHm,y
	// Get delays
	x=box_leftDelay,y
	a=box_rightDelay,y y=a
	// loop condition
	box_lineCount-- ==goto .after
	a=tmp2
	// re-position
	nocross{x--}!= RESP0=a nocross{y--}!= RESM0=a
	goto .display0

.after:
	wsync PF1=PF2=ENAM1=GRP1=COLUP0=COLUP1=a=0
	// Restore stack
	s=x=box_s

	x=8 box_waste COLUBK=a=box_cur_sin wsync COLUBK=a=0

}


/* Set color and y offset for face and draw it
 * IN:
 * a: color eor value
 * x: x index offset
 * y: y index offset
 */
func box_rot2Finalize {
	tmp=a tmp2=x box_lineCount=y
	a=box_frameBase c- a+tmp2 a&63 x=a
	a=box_xStart a|tmp c- a+box_sine_26,x box_xStart=a
	a=box_xEnd a|tmp /*c-*/ a+box_sine_26,x box_xEnd=a
	a=0 c+ a-box_frameBase c- a+box_lineCount a&63 x=a
	a=box_yStart c- a+box_sine_40,x box_yStart=a
	a=box_yEnd /*c-*/ a+box_sine_40,x box_yEnd=a
		
	box_line
}


/* Prepare parameters for rotating boxes
 */
inline box_rotating_init {
	box_frameBase=a=numFrame
	// Set parameters
	x=63
	box_a=a&x
	c- a+16 box_b=a&x
	c- a+16 box_c=a&x
	c- a+16 box_d=a&x
}


/* 2 boxes rotating around common middle line
 * Box 1
 */
func box_2_rotating_1 {
	// Box 1
	// Face 1 y
	x=box_a y=box_b a=box_sine_36,y a?box_sine_36,x >={
		// y=a->b, x=b->c
		box_yEnd=a box_yStart=a=box_sine_36,x
		box_xStart=a=box_sine_26,y
		x=box_c box_xEnd=a=box_sine_26,x
	} else {
		// y=c->d, y=d->a
		x=box_c box_yStart=a=box_sine_36,x
		x=box_d box_yEnd=a=box_sine_36,x
		box_xStart=a=box_sine_26,x
		x=box_a box_xEnd=a=box_sine_26,x
	}
	a=0b00000000 x=a y=16 box_rot2Finalize

	// Face 2 y
	x=box_b y=box_c a=box_sine_36,y a?box_sine_36,x >={
		// y=b->c, x=c->d
		box_yEnd=a box_yStart=a=box_sine_36,x
		box_xStart=a=box_sine_26,y
		x=box_d box_xEnd=a=box_sine_26,x
	} else {
		// y=d->a, y=a->b
		x=box_d box_yStart=a=box_sine_36,x
		x=box_a box_yEnd=a=box_sine_36,x
		box_xStart=a=box_sine_26,x
		x=box_b box_xEnd=a=box_sine_26,x
	}
	a=0b10000000 x=0 y=16 box_rot2Finalize
}


/* 2 boxes rotating around common middle line
 * Box 2
 */
func box_2_rotating_2 {
	// Box 2
	// Face 1 y
	x=box_a y=box_b a=box_sine_36,y a?box_sine_36,x >={
		// y=a->b, x=b->c
		box_yEnd=a box_yStart=a=box_sine_36,x
		box_xStart=a=box_sine_26,y
		x=box_c box_xEnd=a=box_sine_26,x
	} else {
		// y=c->d, y=d->a
		x=box_c box_yStart=a=box_sine_36,x
		x=box_d box_yEnd=a=box_sine_36,x
		box_xStart=a=box_sine_26,x
		x=box_a box_xEnd=a=box_sine_26,x
	}
	a=0b01000000 x=32 y=48 box_rot2Finalize

	// Face 2 y
	x=box_b y=box_c a=box_sine_36,y a?box_sine_36,x >={
		// y=b->c, x=c->d
		box_yEnd=a box_yStart=a=box_sine_36,x
		box_xStart=a=box_sine_26,y
		x=box_d box_xEnd=a=box_sine_26,x
	} else {
		// y=d->a, y=a->b
		x=box_d box_yStart=a=box_sine_36,x
		x=box_a box_yEnd=a=box_sine_36,x
		box_xStart=a=box_sine_26,x
		x=box_b box_xEnd=a=box_sine_26,x
	}
	a=0b11000000 x=32 y=48 box_rot2Finalize

}


/* Set color and y offset for rot4 face and draw it
 * IN:
 * a: color eor value
 * x: x index offset
 * y: y index offset
 */
func box_rot4Finalize_upper {
	tmp=a tmp2=x box_lineCount=y
	a=box_frameBase c- a+tmp2 a&63 x=a
	a=box_xStart a|tmp c- a+box_sine_26,x box_xStart=box_xStart2=a
	a=box_xEnd a|tmp /*c-*/ a+box_sine_26,x box_xEnd=box_xEnd2=a
	
	a=box_frameBase /*c-*/ a+box_lineCount a&63 x=a
	a=box_yStart c- a+box_sine_20,x box_yStart=box_yStart2=a
	a=box_yEnd /*c-*/ a+box_sine_20,x box_yEnd=box_yEnd2=a
		
	box_line
}


/* Repeat box drawing 40 below with different color.
 * IN: a=color eor value
 */
func box_rot4_duplicate {
	tmp=a
	// Repeat for lower box with different color
	a=box_xStart2 a^tmp box_xStart=a
	a=box_xEnd2 a^tmp box_xEnd=a
	a=box_yStart2 c- a+40 box_yStart=a
	a=box_yEnd2 /*c-*/ a+40 box_yEnd=a
	box_line
}


/* 4 boxes, face 1
 */
func box_rot4_face1 {
	// Face 1 y
	x=box_a y=box_b a=box_sine_20,y a?box_sine_20,x >={
		// y=a->b, x=b->c
		box_yEnd=a box_yStart=a=box_sine_20,x
		box_xStart=a=box_sine_26,y
		x=box_c box_xEnd=a=box_sine_26,x
	} else {
		// y=c->d, y=d->a
		x=box_c box_yStart=a=box_sine_20,x
		x=box_d box_yEnd=a=box_sine_20,x
		box_xStart=a=box_sine_26,x
		x=box_a box_xEnd=a=box_sine_26,x
	}
}


/* 4 boxes, face 2
 */
func box_rot4_face2 {
	x=box_b y=box_c a=box_sine_20,y a?box_sine_20,x >={
		// y=b->c, x=c->d
		box_yEnd=a box_yStart=a=box_sine_20,x
		box_xStart=a=box_sine_26,y
		x=box_d box_xEnd=a=box_sine_26,x
	} else {
		// y=d->a, y=a->b
		x=box_d box_yStart=a=box_sine_20,x
		x=box_a box_yEnd=a=box_sine_20,x
		box_xStart=a=box_sine_26,x
		x=box_b box_xEnd=a=box_sine_26,x
	}
}

 
/* 4 boxes rotating, upper
 */
func box_rot4_upper {
	// Box 1
	box_rot4_face1
	a=0b00000000 x=a y=16 box_rot4Finalize_upper
	a=0b01000000 box_rot4_duplicate
	
	// Face 2 y
	box_rot4_face2
	a=0b00000000 x=a y=16 box_rot4Finalize_upper
	a=0b01000000 box_rot4_duplicate
}


/* 4 boxes rotating, lower
 */
func box_rot4_lower {
	// Box 1
	// Face 1 y
	box_rot4_face1
	a=0b10000000 x=32 y=48 box_rot4Finalize_upper
	a=0b01000000 box_rot4_duplicate
	
	// Face 2 y
	box_rot4_face2
	a=0b10000000 x=32 y=48 box_rot4Finalize_upper
	a=0b01000000 box_rot4_duplicate
}


/* Set color and y offset for big box face and draw it
 * IN:
 * a: color eor value
 */
func box_bigFinalize {
	tmp=a
	a=box_xStart a|tmp c+ a-5 box_xStart=a
	a=box_xEnd a|tmp c+ a-5 box_xEnd=a

	a=box_yStart c- a+20 box_yStart=a
	a=box_yEnd a+20 box_yEnd=a
		
	box_line
}


/* Draw big box
 */
func box_big {
	a=0 c+ a-numFrame box_frameBase=a
	// Invert parameters
	x=63
	box_a=a&x
	c- a+16 box_b=a&x
	a+16 box_c=a&x
	a+16 box_d=a&x

	// Face 1 y
	x=box_a y=box_b a=box_sine_40,y a?box_sine_40,x >={
		// y=a->b, x=b->c
		box_yEnd=a box_yStart=a=box_sine_40,x
		box_xStart=a=box_sine_40,y
		x=box_c box_xEnd=a=box_sine_40,x
	} else {
		// y=c->d, y=d->a
		x=box_c box_yStart=a=box_sine_40,x
		x=box_d box_yEnd=a=box_sine_40,x
		box_xStart=a=box_sine_40,x
		x=box_a box_xEnd=a=box_sine_40,x
	}
	a=0b00000000 box_bigFinalize

	// Face 2 y
	x=box_b y=box_c a=box_sine_40,y a?box_sine_40,x >={
		// y=b->c, x=c->d
		box_yEnd=a box_yStart=a=box_sine_40,x
		box_xStart=a=box_sine_40,y
		x=box_d box_xEnd=a=box_sine_40,x
	} else {
		// y=d->a, y=a->b
		x=box_d box_yStart=a=box_sine_40,x
		x=box_a box_yEnd=a=box_sine_40,x
		box_xStart=a=box_sine_40,x
		x=box_b box_xEnd=a=box_sine_40,x
	}
	a=0b01000000 box_bigFinalize

	box_frameBase=a=numFrame

	// Re-invert parameters
	x=63 box_a=a&x
	c- a+16 box_b=a&x
	a+16 box_c=a&x
	a+16 box_d=a&x
}


/* Set color and y offset for small boxes/big face and draw it
 * IN:
 * a: color eor value
 * x: x index offset
 * y: y index offset
 */
func box_bigSmallFinalize {
	a=box_frameBase c- a+tmp2 a&63 x=a
	a=box_xStart a|tmp c- a+3 a+box_sine_26,x box_xStart=a
	a=box_xEnd a|tmp a+3 a+box_sine_26,x box_xEnd=a
	
	a=0 c+ a-box_frameBase c- a+box_lineCount a&63 x=a
	a=box_yStart c- a+box_sine_68,x box_yStart=a
	a=box_yEnd a+box_sine_68,x box_yEnd=a
		
	box_line
}


/* Draw small boxes
 * IN:
 * a: color eor value
 * x: x index offset
 * y: y index offset
 */
func box_big_small {
	tmp=a tmp2=x box_lineCount=y

	// Face 1 y
	x=box_a y=box_b a=box_sine_20,y a?box_sine_20,x >={
		// y=a->b, x=b->c
		a>> box_yEnd=a a=box_sine_20,x a>> box_yStart=a
		box_xStart=a=box_sine_20,y
		x=box_c box_xEnd=a=box_sine_20,x
	} else {
		// y=c->d, y=d->a
		x=box_c a=box_sine_20,x a>> box_yStart=a
		x=box_d a=box_sine_20,x a>> box_yEnd=a
		box_xStart=a=box_sine_20,x
		x=box_a box_xEnd=a=box_sine_20,x
	}
	box_bigSmallFinalize

	// Face 2 y
	x=box_b y=box_c a=box_sine_20,y a?box_sine_20,x >={
		// y=b->c, x=c->d
		a>> box_yEnd=a a=box_sine_20,x a>> box_yStart=a
		box_xStart=a=box_sine_20,y
		x=box_d box_xEnd=a=box_sine_20,x
	} else {
		// y=d->a, y=a->b
		x=box_d a=box_sine_20,x a>> box_yStart=a
		x=box_a a=box_sine_20,x a>> box_yEnd=a
		box_xStart=a=box_sine_20,x
		x=box_b box_xEnd=a=box_sine_20,x
	}
	a=tmp a^0b01000000 tmp=a box_bigSmallFinalize
}


/* Set color and y offset for cube face and draw it
 * IN:
 * a: color eor value
 * x: x index offset
 * y: y index offset
 */
func box_cubeFinalize {
	// calc overall y sin
	a=0 c+ a-box_frameBase c- a+24 a&63 x=a box_cur_sin=a=box_sine_20,x
	
	a=box_frameBase c- a+tmp2 a&63 x=a
	a=box_xStart a|tmp c- a+box_cur_sin a+box_sine_20,x c+ a-5 box_xStart=a
	a=box_xEnd a|tmp c- a+box_cur_sin a+box_sine_20,x c+ a-5 box_xEnd=a

	// Calc overall y sin +pi for circle movement
	a=0 c+ a-box_frameBase c- a+8 a&63 x=a box_cur_sin=a=box_sine_36,x
	
	a=box_frameBase c- a+32 a+box_lineCount a&63 x=a
	a=box_yStart c- a+box_cur_sin a+box_sine_26,x box_yStart=a
	a=box_yEnd a+box_cur_sin a+box_sine_26,x box_yEnd=a
		
	box_line
}


/* Draw cube box
 * IN:
 * tmp: color eor value
 * x: x index offset (y=x+16)
 */
func box_cube_box {
	tmp2=x a=x c- a+16 a&63 box_lineCount=a

	// Face 1 y
	x=box_a y=box_b a=box_sine_36,y a?box_sine_36,x >={
		// y=a->b, x=b->c
		a>> box_yEnd=a a=box_sine_36,x a>> box_yStart=a
		box_xStart=a=box_sine_20,y
		x=box_c box_xEnd=a=box_sine_20,x
	} else {
		// y=c->d, y=d->a
		x=box_c a=box_sine_36,x a>> box_yStart=a
		x=box_d a=box_sine_36,x a>> box_yEnd=a
		box_xStart=a=box_sine_20,x
		x=box_a box_xEnd=a=box_sine_20,x
	}
	box_cubeFinalize

	// Face 2 y
	x=box_b y=box_c a=box_sine_36,y a?box_sine_36,x >={
		// y=b->c, x=c->d
		a>> box_yEnd=a a=box_sine_36,x a>> box_yStart=a
		box_xStart=a=box_sine_20,y
		x=box_d box_xEnd=a=box_sine_20,x
	} else {
		// y=d->a, y=a->b
		x=box_d a=box_sine_36,x a>> box_yStart=a
		x=box_a a=box_sine_36,x a>> box_yEnd=a
		box_xStart=a=box_sine_20,x
		x=box_b box_xEnd=a=box_sine_20,x
	}
	box_cubeFinalize
}


func box_cube_nextsmallest {
	box_min=a=0xff
	x=3 {
		a=box_sort,x !=goto .noTest
		a=x a<< a<< a<< a<< c- a+box_frameBase a&63 y=a
		a=box_sine_26,y a?box_min <{ box_min=a box_minIndex=x }
.noTest:
		x--
	}>=0
	x=box_minIndex box_sort,x=a=1
	tmp=a=box_cube_box_cols,x
	a=x a<< a<< a<< a<< x=a
	goto box_cube_box
}
data box_cube_box_cols {
	0b00000000 0b01000000 0b10000000 0b11000000
}


/* Multiplex box advance: overscan
 */
inline box_advance_overscan {
	a=demoState a>>
	a?[STATE_BOX_ROT2] !=goto .notBox2
	
	// BOX_ROT_2
	box_rotating_init
	a=box_frameBase c- a-16 a&63 a?32 >={
		box_2_rotating_1
	} else {
		box_2_rotating_2
	}
	goto .end
	
.notBox2:
	a?[STATE_BOX_BIG] !=goto .notBig
	
	// BOX_BIG
	box_rotating_init
	x=32 y=48 a=box_frameBase c- a+16 a&63 a?32 <{
		x=0 y=16
	}
	a=0b11000000 box_big_small
	box_big
	goto .end
	
.notBig:
	a?[STATE_BOX_ROT4] !=goto .notRot4

	// BOX_ROT_4
	box_rotating_init
	a=box_frameBase c- a-16 a&63 a?32 >={
		box_rot4_upper
	} else {
		box_rot4_lower
	}
	goto .end

.notRot4:
	// BOX_CUBE
	box_rotating_init
	box_sort=a=0 box_sort+1=a box_sort+2=a box_sort+3=a
	box_cube_nextsmallest
	box_cube_nextsmallest

/*
	a=box_frameBase c- a+8 a&63 a?32 >={
		a?48 >={
			// 48-63
			x=16 box_cube_box
			x=0
		} else {
			// 31-47
			x=32 box_cube_box
			x=48
		}
	} else {
		a?16 >={
			// 16-31
			x=48 box_cube_box
			x=0
		} else {
			// 0-15
			a?8 <{
				x=0 box_cube_box
				x=16
			} else {
				x=0 
				box_cube_box
				x=16
			}
		}
	}
	box_cube_box
*/
	
.end:
}


/* Multiplex box advance: VBlank
 */
inline box_advance_vblank {
	a=demoState a>> a?[STATE_BOX_ROT2] !=goto .notBox2

	// BOX_ROT_2
	a=box_frameBase c- a-16 a&63 a?32 >={
		box_2_rotating_2
	} else {
		box_2_rotating_1
	}
	goto .end

.notBox2:
	a?[STATE_BOX_BIG] !=goto .notBig

	// BOX_BIG
	x=32 y=48
	a=box_frameBase c- a+16 a&63 a?32 >={
		x=0 y=16
	}
	a=0b11000000 box_big_small
	goto .end

.notBig:
	a?[STATE_BOX_ROT4] !=goto .notRot4

	// BOX_ROT_4
	a=box_frameBase c- a-16 a&63 a?32 >={
		box_rot4_lower
	} else {
		box_rot4_upper
	}
	goto .end

.notRot4:
	
	// BOX_CUBE
	box_cube_nextsmallest
	box_cube_nextsmallest

.end:
}


/* Main
 */
func box_main {
	s=x=0xff

	// Init
	demoState=a=0 numFrame=a

	VDELP0=VDELP1=ENABL=a=0
	NUSIZ0=NUSIZ1=a=[ONE_COPY | MSL_SIZE_8]
	CTRLPF=a=[PF_MIRRORED]
	!=goto BoxStart

	// Kernel
	{
		/**************************************************
		 * Overscan
		 **************************************************/
		
		overscan_start

BoxStart:

		// Script
		numFrame++ a=numFrame a?[STATE_BOX_DURATION] =={
			numFrame=a=0 demoState++
			a=demoState a>> a?[STATE_BOX_END] =={far lines_main}
		}
		
		box_advance_overscan
							
		overscan_end


		/**************************************************
		 * VBlank
		 **************************************************/
		
		vblank_start

		box_advance_vblank

		far music
		
		vblank_end

		
		/**************************************************
		 * Visible screen
		 **************************************************/
		
		screen_start

		box_display

		box_clear
		
		screen_end
		
	} always
}
