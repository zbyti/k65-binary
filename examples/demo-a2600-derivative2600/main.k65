/* TODO:
 *
 * Optimize:
 * - Size: Display scroll: separate GRP=a=xx into a=xx GRP=a and intermingle sleeps better
 * - Size: In display_rubber, instead of using NUSIZTable, check bits #6 and #7 with bmi/bvs and load possible NUSIZ values (0, 5, 7) in A manually.
 * - Speed: Incorporate space into font, and remove check for 0
 * - Size: naked functions
 * - Size: &< of tables with align 256 (like color tables) is always 0
 */

 /*
 * Memory layout:
 * - bank core:
 *		- 0xf01d: display_rubber_enter (4 bytes)
 *		- 0xf1d0: display_rubber_return (4 bytes)
 *		- 0xf1d4: music_enter (4 bytes)
 *		- 0xf9c4: show_scroller_trampoline_enter (4 bytes)
 *		- 0xfe44: show_scroller_trampoline_exit (3 bytes)
 *		- 0xfe25: rubber_prepare_enter (4 bytes)
 *		- 0xff25: rubber_prepare_rts (1 byte)
 *		- 0xffec: music_return (4 bytes)
 * - bank rubber:
 * 		- 0xf020: display_rubber (to approx. display_rubber_loop)
 * 		- 0xf03c: display_rubber_loop (to 0xf1d0)
 *		- 0xfe28: rubber_prepare (to 0xff26)
 * - bank data_x:
 * 		- 0xf07f: fetch data #1 (0x14 bytes + rts?)
 * 		- 0xf12c: fetch data #2 (0x14 bytes + rts?)
 *		- 0xfe45: fetch_palette (7 bytes)
 * 
 */


bank core;

//////////////////////////////////////////////////////////////////////
// Vars
//////////////////////////////////////////////////////////////////////

var bank_0=0x1ff4;
var bank_core=0x1ff8;
var bank_rubber=0x1ff9;	// Hard-coded in data_x.k65!
var bank_music=0x1ffb;
var bank_data_1=0x1ff6;

// Permanent
var numFrame=0x80, demoState;
var scr_cnt, scr_ptr[2];
var cubeFrame;
var gradientScr;

// Temporary
var tmp, tmp2;

// Logo tmp vars
var logoCurLine=0x89, logoEndLine;
var logoHMP, slicePtrAdd;
var curSlice;
var sliceColOffset;
var s1[2], s2[2], s3[2], s4[2], s5[2], s6[2];
var slideTarget[2];
var delay_seq, delay_step;
var sync_seq_ptr[2], sync_step_ptr[2];

// Scroll tmp vars (glyph store)
var scr[114]=0x89;

// Var end
var var_scr_end ?;



//////////////////////////////////////////////////////////////////////
// Script
//////////////////////////////////////////////////////////////////////

/* demoState is used as index
 *
 * 0: initial pause
 * 1: Cluster
 * 2: DMA
 * 3: Glitch down to still face
 * 4: Still face
 * 5: Rotating dark blob, glitching
 * 6: Single-color cube
 * 7: Rubberized single-color cube
 * 8: Full rgb cube
 * 9: Full cube, more bend, backwards
 * 10: 3-Split cube
 * 11: 3-split backwards
 * 12: 3-split rubber
 * 13: 3-split rubber
 * 14: quick-jumping
 * 15: quick-jumping with palette change
 * 16: Wind up
 * 17: Wind down
 * 18-21: Even more bend
 *
 * 22: Nordlicht
 * 23: Empty
 */

// 0 means state itself advances demoState
data state_durations {
	255			// Initial pause
	255	255		// Logos
	255	200	0	// Glitch down, still face, rotate blob cube
	0			// Single-color cube
	0			// Rubberized single-color
	65			// Full rgb cube
	250			// Full cube, more bend, backwards
	175			// 3-Split cube
	100			// 3-Split backwards
	30			// 3-split cube rubber
	220			// 3-split cube rubber backwards
	0			// Quick-jumping
	0			// Quick-jumping with palette change
	0			// Wind up
	0			// Wind down
	185			// Dark wobbler
	110			// Wobbler 1
	45			// Wobbler 2
	226			// Wobbler 3
	0			// Waste time rubber cube
	0			// Waste time rubber cube
	0			// Waste time rubber cube
	0			// Waste time rubber cube
	
	0			// Nordlicht
	0			// Empty
	
	// FIXME: Needed to instantiate funcs for linker
	&<show_scroller
	&<show_scroller_trampoline_exit
	&<music
	&<music_return
}

// Rubber hue config according to demoState
// 0: dark blob
// 1: interleaved
// 2: single
// 3: light blob 1
// 4: light blob 2
// 5: light blob 3
// 99: Irrelevant (no cube)
data rubber_hue_configs {
	99
	99 99
	0 0 0
	2 2 1
	1
	99 99 99 99
	1 1
	1 1
	0 3 4 5
	1 1 1 1
	//99
}

// Rubber palette config according to demoState
// 0: dark
// 1: rgb
// 99: irrelevant (no cube)
data rubber_palette_configs {
	99
	99 99
	0 0 0
	0 0 0
	0
	99 99 99 99
	1 1
	0 1
	0 0 0 0
	0 1 0 1
	
	//99
}

// Rubber bend config according to demoState
// 0: No bend
// 1: "Normal" bend 0/100
// 2: Glitch
// 3: "More" bend 0/150
// 4: Even more bend (1/100)
// 5-8: Wobbler bends
// 9: Interlace
// 99: irrelevant (no cube)
data rubber_bend_configs {
	99
	99 99
	0 0 0
	0 1 1
	3
	99 99 99 99
	1 3
	99 99
	5 6 7 8
	3 4 5 9
	
	//99
}

// Add to cubeFrame
data rubber_rotate_configs {
	99
	99 99
	0 0 1
	1 1 1
	255
	99 99 99 99
	255 1
	99 99
	2 251 4 253
	1 255 1 255
	
	//99
}



// Vblank und overscan routines
data vblank_lo {
	&<vblank_empty
	&<vblank_logo_cluster
	&<vblank_logo_dma
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube_3split
	&<vblank_cube_3split
	&<vblank_cube_3split
	&<vblank_cube_3split
	&<vblank_cube_quickjmp
	&<vblank_cube_quickjmp
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube
	&<vblank_cube

	&<vblank_logo_nordlicht	
	&<vblank_empty
}
data vblank_hi {
	&>vblank_empty
	&>vblank_logo_cluster
	&>vblank_logo_dma	
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube_3split
	&>vblank_cube_3split
	&>vblank_cube_3split
	&>vblank_cube_3split
	&>vblank_cube_quickjmp
	&>vblank_cube_quickjmp
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube
	&>vblank_cube

	&>vblank_logo_nordlicht
	&>vblank_empty
}

data overscan_lo {
	&<overscan_empty
	&<overscanEnd
	&<overscanEnd
	&<overscan_cube_glitch_down
	&<overscan_cube
	&<overscan_cube_dark_glitch
	&<overscan_cube
	&<overscan_cube
	&<overscan_cube
	&<overscan_cube
	&<overscan_cube_3split
	&<overscan_cube_3split
	&<overscan_cube_3split
	&<overscan_cube_3split
	&<overscan_cube_quickjmp
	&<overscan_cube_quickjmp
	&<overscan_cube_wind
	&<overscan_cube_wind
	&<overscan_cube
	&<overscan_cube
	&<overscan_cube
	&<overscan_cube
	&<overscan_cube_songadvance
	&<overscan_cube_songadvance
	&<overscan_cube_songadvance
	&<overscan_cube_songadvance

	&<overscanEnd	
	&<overscan_empty
}
data overscan_hi {
	&>overscan_empty
	&>overscanEnd
	&>overscanEnd
	&>overscan_cube_glitch_down
	&>overscan_cube
	&>overscan_cube_dark_glitch
	&>overscan_cube
	&>overscan_cube
	&>overscan_cube
	&>overscan_cube
	&>overscan_cube_3split
	&>overscan_cube_3split
	&>overscan_cube_3split
	&>overscan_cube_3split
	&>overscan_cube_quickjmp	
	&>overscan_cube_quickjmp	
	&>overscan_cube_wind
	&>overscan_cube_wind
	&>overscan_cube
	&>overscan_cube
	&>overscan_cube
	&>overscan_cube
	&>overscan_cube_songadvance
	&>overscan_cube_songadvance
	&>overscan_cube_songadvance
	&>overscan_cube_songadvance

	&>overscanEnd
	&>overscan_empty
}

data kernel_lo {
	&<kernel_empty
	&<kernel_logo
	&<kernel_logo
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube
	&<kernel_cube

	&<kernel_logo
	&<kernel_empty
}
data kernel_hi {
	&>kernel_empty
	&>kernel_logo
	&>kernel_logo
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube
	&>kernel_cube

	&>kernel_logo
	&>kernel_empty
}



//////////////////////////////////////////////////////////////////////
// Rubber configurations
//////////////////////////////////////////////////////////////////////

// Hue tables for rubber_prepare
// 0: dark blob
// 1: interleaved
// 2: single
// 3: Light blob 1
data rubber_hue_1_lo {
	&<rubber_gradient_blob
	&<rubber_gradient_interleaved_1
	&<rubber_gradient_single_1
	&<rubber_gradient_single_1
	&<rubber_gradient_single_2
	&<rubber_gradient_single_3
}
data rubber_hue_1_hi {
	&>rubber_gradient_blob
	&>rubber_gradient_interleaved_1
	&>rubber_gradient_single_1
	&>rubber_gradient_single_1
	&>rubber_gradient_single_2
	&>rubber_gradient_single_3
}
data rubber_hue_2_lo {
	&<rubber_gradient_blob
	&<rubber_gradient_interleaved_2
	&<rubber_gradient_single_2
	&<rubber_gradient_single_1
	&<rubber_gradient_single_2
	&<rubber_gradient_single_3
}
data rubber_hue_2_hi {
	&>rubber_gradient_blob
	&>rubber_gradient_interleaved_2
	&>rubber_gradient_single_2
	&>rubber_gradient_single_1
	&>rubber_gradient_single_2
	&>rubber_gradient_single_3
}
data rubber_hue_3_lo {
	&<rubber_gradient_blob
	&<rubber_gradient_interleaved_3
	&<rubber_gradient_single_3
	&<rubber_gradient_single_1
	&<rubber_gradient_single_2
	&<rubber_gradient_single_3
}
data rubber_hue_3_hi {
	&>rubber_gradient_blob
	&>rubber_gradient_interleaved_3
	&>rubber_gradient_single_3
	&>rubber_gradient_single_1
	&>rubber_gradient_single_2
	&>rubber_gradient_single_3
}

// Palette tables for rubber_prepare
// 0: dark
// 1: rgb
data rubber_palette_1_lo {
	&<colorTable1_dark
	&<colorTable1_rgb
}
data rubber_palette_1_hi {
	&>colorTable1_dark
	&>colorTable1_rgb
}
data rubber_palette_2_lo {
	&<colorTable2_dark
	&<colorTable2_rgb
}
data rubber_palette_2_hi {
	&>colorTable2_dark
	&>colorTable2_rgb
}

// Bend adds for rubber kernel
// 0: no bend
// 1: "normal" bend
// 2: Glitch
// 3: "More" bend
// 4: Even more bend
// 5-8: Wobblers
data rubber_frame_add_lo {
	0 100 173 240 100
	128 250 20 67
	0
}
data rubber_frame_add_hi {
	0 0 97 0 2
	2 3 5 6
	75
}


//////////////////////////////////////////////////////////////////////
// Music trampolines
//////////////////////////////////////////////////////////////////////

func music_enter {
	address 0xf1d4
	a&?bank_music
}

func music_return {
	address 0xffec
	goto afterMusic
}


//////////////////////////////////////////////////////////////////////
// Scroller
//////////////////////////////////////////////////////////////////////

/* Scroll text
 * 254: Speed 1
 * 253: Speed 2
 * 252: Stand still
 * 251: Next demo state
 */
data text {
	charset " :abcdefghijklmnopqrstuvwxyz012345678-!.,'?"
	evaluator [x==0 ? 255 : x]
	"                     "
	253 252
	"kylearan     "
	254 252 253
	"            "
	252 253
	"                kk         "
	254 252 253
	"              "
	"in 2014, we finally managed to bring the"
	" impossible wire cube to the vcs 2600."
	" now at nordlicht 2015, we are back with more derivative"
	" goodness! please give a warm welcome to...    the filled cube! "
	251 254 252
	"            "
	"and since we are so derivative already, we also rubberized it."
	251
	"quite nice for such a lowly machine, isn't it?"
	251
	"                   "
	252 252 252 252
	" other people need 512k chip plus 512k fast mem - we"
	" are content with 128 bytes of ram and no framebuffer,"
	" thanks to our patented supra-pixel rendering in underscan mode!"
	"                    "
	252 252 252 252
	" by the way, this super-wide hi-res scroller is dedicated to"
	" svolli, who believed this couldn't be done on an unexpanded vcs."
	" that motivated me to try and do it anyway!"
	"                    "
	252 252 252
	" so, what's next? before we can apply for the trilobit"
	" psychedelic method, we have to advance to textured cubes"
	" first...    but not in this little demo!"
	"                    "

	252 252 252
	"code and design by kylearan, music and synth"
	" by kk. thanks for watching!      party on!"
	"      " 252 "              "
}



/* Scroll font
 */
data font {
	nocross
	0x00 0x20 0x20 0x00 0x20 0x20 0x7c 0x82 0xfe 0x82 0x82 0x82 
	0xfc 0x82 0xfc 0x82 0x82 0xfc 0x7e 0x80 0x80 0x80 0x80 0x7e 
	0xfc 0x82 0x82 0x82 0x82 0xfc 0x7e 0x80 0xfc 0x80 0x80 0x7e 
	0x7e 0x80 0xfc 0x80 0x80 0x80 0x7e 0x80 0x9c 0x82 0x82 0x7c 
	0x82 0x82 0xfe 0x82 0x82 0x82 0x7c 0x10 0x10 0x10 0x10 0x7c 
	0x7e 0x02 0x02 0x02 0x82 0x7c 0x82 0x84 0xf8 0x84 0x82 0x82 
	0x80 0x80 0x80 0x80 0x80 0xfe 0x82 0xc6 0xaa 0x92 0x82 0x82 
	0xfc 0x82 0x82 0x82 0x82 0x82 0x7c 0x82 0x82 0x82 0x82 0x7c 
	0xfc 0x82 0xfc 0x80 0x80 0x80 0x7c 0x82 0x82 0x8a 0x86 0x7e 
	0xfc 0x82 0xfc 0x88 0x84 0x82 0x7e 0x80 0x7c 0x02 0x02 0xfc 
	0xfe 0x10 0x10 0x10 0x10 0x10 0x82 0x82 0x82 0x82 0x82 0x7c 
	0x82 0x82 0x82 0x44 0x28 0x10 0x82 0x82 0x92 0xaa 0xc6 0x82 
	0x82 0x44 0x38 0x44 0x82 0x82 0x82 0x44 0x28 0x10 0x10 0x10 
	0xfe 0x06 0x18 0x30 0xc0 0xfe 0x7c 0x82 0x82 0x82 0x82 0x7c 
	0x10 0x30 0x10 0x10 0x10 0x38 0xfc 0x02 0x1c 0x60 0x80 0xfe 
	0xfc 0x02 0x3c 0x02 0x02 0xfc 0x40 0x48 0x48 0x7e 0x08 0x08 
	0xfe 0x80 0xfc 0x02 0x02 0xfc 0x7e 0x80 0xfc 0x82 0x82 0x7c 
	0x7e 0x02 0x04 0x08 0x10 0x10 0x7c 0x82 0x7c 0x82 0x82 0x7c 
	0x00 0x00 0x7e 0x00 0x00 0x00 0x20 0x20 0x20 0x20 0x00 0x20 
	0x00 0x00 0x00 0x00 0x20 0x20 0x00 0x00 0x00 0x10 0x10 0x20 
	0x10 0x10 0x10 0x00 0x00 0x00 0x78 0x04 0x08 0x10 0x00 0x10 
}



/* Process scroller
 * scr_cnt:
 * - bit 7: fast or slow
 * - bit 0..2: soft scroll pos
 * - >=8: Stand still
 */
func do_scroll {
	// isolate speed flag
	a=scr_cnt a&128 tmp=a	
	// cnt>8 means scroller stands still. Ignore bit #7, as it's the double speed bit
	a=scr_cnt a&127 a?8 >={
		// Cound down for stand still
		c+ a-1 a?8 =={a=0} a|tmp scr_cnt=a
	} else {
		x=a x++ x?8 =={
			scr_ptr++ =={scr_ptr+1++}
			x=0
			// Test for special speed markers
			y=20 a=(scr_ptr),y <0{
				a?253 =={
					// Speed 2
					tmp=a=128 !=goto .after
				}
				a?254 =={
					// Speed 1
					tmp=x ==goto .after
				}
				a?252 =={
					// Stand still
					x=127 !=goto .after
				}
				a?251 =={
					demoState++
					}
.after:
			}
		}
		a=x a|tmp scr_cnt=a
	}
}



/* Copy glyphs to sprite buffer
 */
data mul6Table {
	nocross
	0
	for x=0..42 eval [x*6]
}
inline  create_scroller {
	tmp=x=0 nocross {
		y=tmp y?19 ==goto .end
		x=mul6Table+1,y
		a=(scr_ptr),y <0{
			// Space
			a=0
			scr+0,x=a scr+1,x=a scr+2,x=a scr+3,x=a scr+4,x=a scr+5,x=a
			==goto .afterElse
		}
		// Glyph
		// *6 to get glyph address
		y=a a=mul6Table,y y=a
		scr+0,x=a=font,y scr+1,x=a=font+1,y scr+2,x=a=font+2,y
		scr+3,x=a=font+3,y scr+4,x=a=font+4,y scr+5,x=a=font+5,y
.afterElse:
		tmp++
	}always
.end:
}



/* Kernel: Show scroller trampolines
 */

func show_scroller_trampoline_enter {
	address 0xf9c4
	a&?bank_data_1
}

func show_scroller_trampoline_exit {
	address 0xfe44
	goto afterShowScroller
}



//////////////////////////////////////////////////////////////////////
// Logos
//////////////////////////////////////////////////////////////////////

data DMA {
	nocross
	0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
	0x00 0x00 0x00 0x00 0x00 0x00
	0xff 0xff 0xe3 0xe3 0xe3 0xe3 0xe3 0xe3
	0xe3 0xe3 0xe3 0xe3 0xff 0xfe
	0x1c 0x9c 0x9c 0x9d 0x9d 0x9d 0x9d 0x9d
	0x9d 0x9f 0x9f 0x9f 0x9f 0x1f
	0xce 0xce 0xce 0xee 0xee 0xee 0xee 0xae
	0xae 0xbe 0xbe 0x1e 0x1e 0x1e
	0xe3 0xe3 0xe3 0xff 0xff 0x63 0x63 0x77
	0x77 0x77 0x36 0x36 0x3e 0x3e
	0x80 0x80 0x80 0x80 0x80 0x00 0x00 0x00
	0x00 0x00 0x00 0x00 0x00 0x00
}

data Cluster {
	nocross
	0x3c 0x7e 0xe7 0xe7 0xe7 0xe7 0xe0 0xe0
	0xe7 0xe7 0xe7 0xe7 0x7e 0x3c
	0x73 0x77 0x77 0x77 0x77 0x77 0x77 0x77
	0x77 0x77 0x77 0x77 0x70 0x70
	0x73 0xf7 0x76 0x76 0x71 0x73 0x77 0x77
	0x77 0x77 0x77 0x73 0x00 0x00
	0xc3 0xe7 0xe7 0xe7 0xe7 0xe7 0xc7 0x87
	0x67 0x6f 0xef 0xc7 0x07 0x00
	0x8f 0x9f 0x3b 0x3b 0x3b 0x38 0x3f 0x3f
	0x3b 0xbb 0xbf 0x1e 0x00 0x00
	0x38 0x38 0xb8 0xb8 0xb8 0x38 0xb8 0xb8
	0xb8 0xbe 0x3e 0x3a 0x00 0x00
}

data Nordlicht {
	nocross
	0xd9 0xdb 0xdb 0xdb 0xdb 0xdb 0xdb 0xdb
	0xdb 0xdb 0xd9 0xd8 0xd8 0xf0
	0xcc 0x6c 0x6c 0x6c 0x6c 0x6c 0x6d 0x6d
	0x6d 0x6d 0xcf 0x00 0x00 0x00
	0x1c 0x36 0x36 0x36 0x36 0x36 0xb6 0xb6
	0xb6 0xb6 0x1e 0x06 0x06 0x06
	0x6c 0xcd 0xcd 0xcd 0xcd 0xcd 0xcd 0xcd
	0xcd 0xcd 0xcc 0xc0 0xcc 0xcc
	0xe6 0xb6 0xb6 0xb6 0xb6 0x86 0x86 0xb6
	0xb6 0xb6 0xe7 0x06 0x06 0x06
	0xce 0xd8 0xd8 0xd8 0xd8 0xd8 0xd8 0xd8
	0xd8 0xde 0x98 0x18 0x00 0x00
}



//////////////////////////////////////////////////////////////////////
// Rubber trampolines
//////////////////////////////////////////////////////////////////////

// Just an rts after rubber_prepare
func rubber_prepare_rts {
	address 0xff25
}

// Switch banks to enter rubber_prepare
func rubber_prepare_enter {
	address 0xfe25
	a&?bank_rubber
}

// Jmp back to main loop after display_rubber
func display_rubber_return {
	address 0xf1d0
	goto afterDisplayRubber
}

// Switch banks to enter display_rubber
func display_rubber_enter {
	address 0xf01d
	a&?bank_rubber
}



//////////////////////////////////////////////////////////////////////
// Kernel routines
//////////////////////////////////////////////////////////////////////

/* Logo kernel
 */
// startLine, endLine, and lineAdd for slices
data slice_start {
	nocross
	0 2 4 6 13 13 13 13 13
}
data slice_end {
	nocross
	255 255 255 255 255 6 8 10 12
}
data slice_gap {
	4 4 2 1 1 2 4 4 30
}
data slice_gradient {
	nocross
	0x94 0x94 0x94 0x96 0x98 0x9a 0x9c 0x9e 0x7e
}
data slice_grad_sub {
	4 3 2 1 0 1 2 3 4
}
data slice_grad_max {
	4 5 6 7 8 7 6 5 4
}

func main_sl12 {}

naked kernel_logo {
	HMP0=HMP1=a=logoHMP
	
	curSlice=a=8
	{
		x=curSlice
		// Empty lines
		y=slice_gap,x { wsync y--}!=
		// Set parameters
		logoEndLine=a=slice_end,x
		logoCurLine=y=slice_start,x
		
		a=sliceColOffset c+ a-slice_grad_sub,x <0{a=0}
		a?slice_grad_max,x >={a=slice_grad_max,x}
		
		wsync
		x=a COLUP0=COLUP1=a=slice_gradient,x
		main_sl12 main_sl12 main_sl12 sl11 //*59 since wsync
		goto (slideTarget)
		nocross {
nopSlide:
			a?0xc9
			a?0xc9
			a?0xc9
			a?0xc9
			a?0xc9
			a?0xc9
			a?0xc9
			a?0xc5
			*2
		}
		nocross{
			GRP0=a=(s1),y GRP1=a=(s2),y GRP0=a=(s3),y
			tmp=a=(s6),y
			a=x=(s5),y
			a=(s4),y
			y=tmp
			GRP1=a GRP0=x GRP1=y GRP0=a
			sl5
			y=logoCurLine y-- logoCurLine=y
			y?logoEndLine
		}!=
		
		GRP0=GRP1=GRP0=a=0
		a=slideTarget c- a+slicePtrAdd slideTarget=a
		wsync hmove
		curSlice-- <0{goto .endSlice}
	}always
.endSlice:
	
	goto kernelEnd	
}



/* Cube kernel
 */
naked kernel_cube {
	COLUP0=COLUP1=a=0x94
	goto display_rubber_enter //far display_rubber
afterDisplayRubber:

	goto kernelEnd
}



/* Empty kernel
 */
naked kernel_empty {
	goto kernelEnd
}



//////////////////////////////////////////////////////////////////////
// Overscan routines
//////////////////////////////////////////////////////////////////////

/* Empty
 */
naked overscan_empty {
	goto overscanEnd
}



/* Cube: Glitch down to still face
*/
naked overscan_cube_glitch_down {
	// Make sure numFrame is at least 130, so it doesn't take too long and
	// eor #255 glitching works
	a=numFrame a?100 <{numFrame=a=100}
	a^0xff tmp=a
	a>> frameAdd=a
	a=tmp a&127 frameAddLo=a=0
	curFrame=curFrameLo=a
	x=a y=a
	goto RubberPrepareParamsNoBend
}



/* Cube: Dark blob glitching
*/
naked overscan_cube_dark_glitch {
	// Advance cube
	a=numFrame a&1 =={
		x=cubeFrame x++ x?150 >={x=0} cubeFrame=x
	}
	
	// Fetch hue
	y=demoState	x=rubber_hue_configs,y
	// Bend: glitch?
	a=songpos_step a&3 a?1 =={
		a=13
	} else {
		a=0
	}
	frameAdd=a frameAddLo=a=0
	curFrameLo=a
	curFrame=a=cubeFrame 
	goto RubberPrepareParamsNoBend
}



/* 3-Split cube
 */
naked overscan_cube_3split {
	// Advance cube
	a=numFrame a&1 =={
		x=cubeFrame x++ x?150 >={x=0} cubeFrame=x
		x=gradientScr x++ x?40 =={x=0} gradientScr=x
	}
	
	// Bend parameters
	curFrame=a=cubeFrame curFrameLo=a=0
	frameAdd=a
	x=demoState x?12 =={
		a=255
	}
	x?13 =={
		a=255
	}
	frameAddLo=a

	// Color table ptrs
	colTablePtr1=a=&<rubber_gradient_interleaved_1 colTablePtr1+1=a=&>rubber_gradient_interleaved_1
	colTablePtr2=a=&<rubber_gradient_interleaved_1 colTablePtr2+1=a=&>rubber_gradient_interleaved_1
	colTablePtr3=a=&<rubber_gradient_interleaved_3 colTablePtr3+1=a=&>rubber_gradient_interleaved_3
	
	// Advance gradient scroll
	a=colTablePtr1 c- a+gradientScr colTablePtr1=a
	a=colTablePtr2 a+gradientScr colTablePtr2=a
	a=39 c+ a-gradientScr tmp=a
	a=colTablePtr3 c- a+tmp colTablePtr3=a
	
	// If second split state, invert cube frame
	a=demoState a?11 =={
		a=149 c+ a-curFrame curFrame=a
	}
	a=demoState a?13 =={
		a=149 c+ a-curFrame curFrame=a
	}
	
	// Do first prepare
	x=0 a=14 rubber_prepare_enter //far rubber_prepare
	
	// Change frame and direction
	//a=curFrame c- a+75 a?150 >={c+ a-150} curFrame=a
	a=149 c+ a-curFrame curFrame=a
	
	// Color table ptrs
	colTablePtr1=a=&<rubber_gradient_interleaved_2 colTablePtr1+1=a=&>rubber_gradient_interleaved_2
	colTablePtr2=a=&<rubber_gradient_interleaved_2 colTablePtr2+1=a=&>rubber_gradient_interleaved_2
	// Advance gradient scroll
	a=colTablePtr1 c- a+gradientScr colTablePtr1=a
	a=colTablePtr2 a+gradientScr colTablePtr2=a

	// Do first half of second prepare
	x=14 a=17 rubber_prepare_enter //far rubber_prepare	

	goto overscanEnd
}



/* Quick-jmp cube
*/
naked overscan_cube_quickjmp {
	// Next state?
	a=demoState a?14 =={
		a=songpos_seq a?0x2c =={
			demoState++
		}
	} else {
		a=songpos_seq a?0x30 =={
			demoState++ numFrame=a=0
		}
	}

	// Check for speed jmp
	a=songpos_step a&3 a?2 =={
		a=cubeFrame c- a+3 a?150 >={c+ a-150} cubeFrame=a
	}
	
	goto overscan_cube
}



/* Wind cube
*/
naked overscan_cube_wind {
	// End of wind-up?
	a=songpos_seq a&1 =={
		a=songpos_step a|songpos_tick =={
			// Max was 0xb7; now reset
			numFrame=a=0
		}
	}

	// Next demo state?
	a=songpos_seq a?0x34 =={
		a=songpos_step a|songpos_tick =={
			demoState++
			a=cubeFrame c- a+30 cubeFrame=a
		}
	} else {
		a?0x38 =={
			demoState++ numFrame=a=0
		}
	}

	
	// Advance cube
	a=numFrame a&1 =={
		x=cubeFrame x-- x?255 =={x=149} cubeFrame=x
		x=gradientScr x++ x?40 =={x=0} gradientScr=x
	}
	
	// Bend parameters
	curFrame=a=cubeFrame curFrameLo=a=0
	a=numFrame
	x=songpos_seq x?0x32 >={
		x?0x34 ==goto .noInvert
		x?0x35 ==goto .noInvert
		a=0xb7 c+ a-numFrame
	}
.noInvert:
	tmp=a
	a>> a>> a>> a>> a>> frameAdd=a
	a=tmp a<< a<< a<< frameAddLo=a
	
	// Fetch hue parameters for this demoState
	y=demoState x=rubber_hue_configs,y

	goto RubberPrepareParamsNoBend
}



/* Cube with demoState advance per songpos_seq
*/
naked overscan_cube_songadvance {
	a=songpos_seq a&7 =={
		a=songpos_step a|songpos_tick =={
			demoState++
		}
	}
	
	// Advance cube
	a=numFrame a&1 =={
		x=demoState a=cubeFrame c- a+rubber_rotate_configs,x
		a?150 >={
			// Check if add or sub
			y=rubber_rotate_configs,x >=0{
				c+ a-150
			} else {
				c- a+150
			}
		}
		cubeFrame=a

		x=gradientScr x++ x?40 =={x=0} gradientScr=x
	}
	
	// Fetch hue and bend parameters for this demoState
	x=demoState
	y=rubber_bend_configs,x
	a=rubber_hue_configs,x x=a

	/* Init for rubber_prepare */
	// Hue state in x, bend state in y
	
	// Bend parameters
	curFrame=a=cubeFrame curFrameLo=a=0
	frameAdd=a=rubber_frame_add_hi,y frameAddLo=a=rubber_frame_add_lo,y

	// Bend: glitch?
	a=demoState a?0x19 ==goto .noGlitch
	a=songpos_step a&7 a?1 =={
		frameAdd=a=13
	}
.noGlitch:

	goto RubberPrepareParamsNoBend
}



/* Cube
 */
naked overscan_cube {
	// Advance cube
	a=numFrame a&1 =={
		x=demoState a=cubeFrame c- a+rubber_rotate_configs,x
		a?150 >={
			// Check if add or sub
			y=rubber_rotate_configs,x >=0{
				c+ a-150
			} else {
				c- a+150
			}
		}
		cubeFrame=a

		x=gradientScr x++ x?40 =={x=0} gradientScr=x
	}
	
RubberPrepareParamsDemoState:
	// Fetch hue and bend parameters for this demoState
	x=demoState
	y=rubber_bend_configs,x
	a=rubber_hue_configs,x x=a

	/* Init for rubber_prepare */
	// Hue state in x, bend state in y
RubberPrepareParams:
	
	// Bend parameters
	curFrame=a=cubeFrame curFrameLo=a=0
	frameAdd=a=rubber_frame_add_hi,y frameAddLo=a=rubber_frame_add_lo,y

RubberPrepareParamsNoBend:

	// Color table ptrs
	colTablePtr1=a=rubber_hue_1_lo,x colTablePtr1+1=a=rubber_hue_1_hi,x
	colTablePtr2=a=rubber_hue_2_lo,x colTablePtr2+1=a=rubber_hue_2_hi,x
	colTablePtr3=a=rubber_hue_3_lo,x colTablePtr3+1=a=rubber_hue_3_hi,x
	
	// Advance gradient scroll
	a=colTablePtr1 c- a+gradientScr colTablePtr1=a
	a=colTablePtr2 c- a+gradientScr colTablePtr2=a
	a=39 c+ a-gradientScr tmp=a
	a=colTablePtr3 c- a+tmp colTablePtr3=a
	
	// Do first prepare
	x=0 a=17 rubber_prepare_enter //far rubber_prepare

	goto overscanEnd
}



//////////////////////////////////////////////////////////////////////
// VBlank routines
//////////////////////////////////////////////////////////////////////

/* Empty
 */
naked vblank_empty {
	// make sure numFrame will start at 0 next demoState
	a=numFrame a?150 =={numFrame=a=254}
	
	CTRLPF=a=[BALL_SIZE_8]
	goto vblankEnd
}



/* Logo: Cluster
 * Leftmost pos: *30
 * Rightmost pos: *46
 */
// numFrame values for pos index change
data logo_cluster_sync_seq {
	0 0 0 0 0 0 0 
	1 1 1 1 1 1 1 1
	2 2 2
	2 2 2 2
	3 3 3
	3 3 3 3 3 3 3 3
	8
}
data logo_cluster_sync_steps {
	8 9 10 12 13 14 15
	8 9 10 11 12 13 14 15
	8 9 10
	12 13 14 15
	4 5 6
	8 9 10 11 12 13 14 15
}
data logo_dma_sync_seq {
	4 4 4 4 4 4 4
	5 5 5 5 5 5 5 5
	6 6 6
	6 6 6 6
	7 7 7
	7 7 7 7 7 7 7 7
	10
}
data logo_cluster_sync_indexes {
	0 1 2 3 4 3 2 
	1 0 1 2 3 4 3 2
	1 0 1
	2 3 4 3
	2 1 0
	1 2 3 4 3 2 1 0
	1	// last position after last beat
}
data logo_HMP {
	HM_LEFT_6 HM_LEFT_3 0 HM_RIGHT_3 HM_RIGHT_6
}
data logo_slice_add {
	2 1 0 255 254
}

naked vblank_logo_cluster {
	delay_seq=a=3
	delay_step=a=14
	sync_seq_ptr=a=&<logo_cluster_sync_seq sync_seq_ptr+1=a=&>logo_cluster_sync_seq
	sync_step_ptr=a=&<logo_cluster_sync_steps sync_step_ptr+1=a=&>logo_cluster_sync_steps
	y=&>Cluster
	a=&<Cluster+70

setupLogo:
	// Set up ptrs and vars	
	s1+1=y s2+1=y s3+1=y s4+1=y s5+1=y s6+1=y
	c+ x=10 {
		s1,x=a
		a-14 x-- x--
	}>=0
	a=numFrame <0{a^0xff}
	a>> sliceColOffset=a

	// For Nordlicht, don't end
	a=demoState a?20 >=goto .delay
	// Delay numFrame until song reaches the end of the pattern
	a=numFrame a?100 <goto .noDelay a?255 ==goto .noDelay
	a=songpos_seq a?delay_seq <{
		a=songpos_step a?delay_step <goto .delay
	}
	goto .noDelay
	
.delay:
	numFrame=a=135
.noDelay:

	// Calc pos index from songpos_seq and _step
	// For Nordlicht: No sync
	a=demoState a?20 <goto .searchIndex
	a=songpos_tick a&7 y=a goto .foundIndex

.searchIndex:
	y=0 {
		a=songpos_seq a?(sync_seq_ptr),y <goto .foundIndex
		=={
			a=songpos_step a?(sync_step_ptr),y <goto .foundIndex ==goto .foundIndex
		}
		y++
	}always
	
.foundIndex:
	x=logo_cluster_sync_indexes,y
	// Reverse for DMA logo
	a=demoState a?2 =={a=4 c+ a-logo_cluster_sync_indexes,y x=a}

	logoHMP=a=logo_HMP,x
	slicePtrAdd=a=logo_slice_add,x
	
	// Calc position. In x: logo sync index
	a=x a<< a<< c- a+&<logoPosSlide slideTarget=a
	slideTarget+1=a=&>logoPosSlide
	
	// Position
	wsync
	sl12 sl11
	goto (slideTarget)
	nocross {
logoPosSlide:
		a?0xc9
		a?0xc9
		a?0xc9
		a?0xc9
		a?0xc9
		a?0xc9
		a?0xc9
		a?0xc5
		*2
		RESP0=a RESP1=a
	}

	HMP0=a=0 HMP1=a=[HM_LEFT_1] wsync hmove
	wsync HMP0=HMP1=a=0

	NUSIZ0=NUSIZ1=a=[THREE_COPIES_CLOSE]
	VDELP0=VDELP1=a=[VDEL_ENABLE]	
	COLUP0=COLUP1=a=0x0e
	
	// Prepare slideTarget for nop slide in kernel
	// in x: logo sync index
	a=x a<< a<< c- a+&<nopSlide slideTarget=a
	slideTarget+1=a=&>nopSlide

	goto vblankEnd
}



/* Logo: DMA
 */
naked vblank_logo_dma {
	delay_seq=a=7
	delay_step=a=14
	sync_seq_ptr=a=&<logo_dma_sync_seq sync_seq_ptr+1=a=&>logo_dma_sync_seq
	sync_step_ptr=a=&<logo_cluster_sync_steps sync_step_ptr+1=a=&>logo_cluster_sync_steps
	y=&>DMA
	a=&<DMA+70	
	goto setupLogo
}
 
 
 
/* Logo: Nordlicht
 */
naked vblank_logo_nordlicht {
	a=songpos_seq a?0x6a =={data {0}}
	y=&>Nordlicht
	a=&<Nordlicht+70	
	goto setupLogo
}
 
 
 
/* 3-Split cube
 */
naked vblank_cube_3split {
	// Do second half of second prepare
	x=17 a=27 rubber_prepare_enter // far rubber_prepare

	// Switch back cur frame
	a=149 c+ a-curFrame curFrame=a
	
	// Color table ptrs
	colTablePtr1=a=&<rubber_gradient_interleaved_1 colTablePtr1+1=a=&>rubber_gradient_interleaved_1
	colTablePtr2=a=&<rubber_gradient_interleaved_1 colTablePtr2+1=a=&>rubber_gradient_interleaved_1
	// Advance gradient scroll
	a=colTablePtr1 c- a+gradientScr colTablePtr1=a
	a=colTablePtr2 a+gradientScr colTablePtr2=a

	// Do third prepare
	x=27 a=40 rubber_prepare_enter // far rubber_prepare
	
	// Set color table ptrs
	colTablePtr1=a=&<colorTable1_rgb colTablePtr1+1=a=&>colorTable1_rgb
	colTablePtr2=a=&<colorTable2_rgb colTablePtr2+1=a=&>colorTable2_rgb

	// Init PF and switch off ball for now
	CTRLPF=a=[PF_MIRRORED | BALL_SIZE_8] ENABL=a=0
	
	goto vblankEnd
}

 
  
/* Quick-jmp cube
*/
naked vblank_cube_quickjmp {
	// Do second prepare
	x=17 a=40 rubber_prepare_enter // far rubber_prepare

	// Palette depends on songpos_step
	x=0
	a=demoState a?15 =={
		a=songpos_step a&8 =={x=1}
	}
	
	goto RubberPreparePalette
}



/* Cube
 */
naked vblank_cube {
	// Do second prepare
	x=17 a=40 rubber_prepare_enter // far rubber_prepare

	// Set color table ptrs
	// Palette index in x
	y=demoState x=rubber_palette_configs,y
	
RubberPreparePalette:
	colTablePtr1=a=rubber_palette_1_lo,x colTablePtr1+1=a=rubber_palette_1_hi,x
	colTablePtr2=a=rubber_palette_2_lo,x colTablePtr2+1=a=rubber_palette_2_hi,x

	// Init PF and switch off ball for now
	CTRLPF=a=[PF_MIRRORED | BALL_SIZE_8] ENABL=a=0
	
	goto vblankEnd
}



//////////////////////////////////////////////////////////////////////
// Main
//////////////////////////////////////////////////////////////////////

data ff_80 {
	0x37 0x19 0x27 0xa2 0xf7 0x74 0x26
}
data ff_msx {
	0x5f 0x08 0x04
}

main {
	/**************************************************
	 * Init
	 **************************************************/	

	init
	
	// scroll text
	scr_ptr=a=&<text scr_ptr+1=a=&>text
	
	// Place ball for hmove masking (ball is never used anywhere else)
	wsync RESBL=a HMBL=a=[HM_LEFT_2] wsync hmove wsync HMBL=a=0

/*
	// Fast forward, for syncing
	songpos_seq=a=ff_msx songpos_step=a=ff_msx+1 songpos_tick=a=ff_msx+2
	x=6 {
		numFrame,x=a=ff_80,x
		x--
	}>=0
*/


	/**************************************************
	 * Start demo
	 **************************************************/
	
	{
		/**************************************************
		 * Overscan
		 **************************************************/
		
		overscan_start

		// Advance frame and state
		numFrame++
		a=numFrame !={
			// 0 in state_durations means state itself advances demoState
			 x=demoState a?state_durations,x =={
				 demoState++
			 }
		}
		
		// jmp to correct overscan routine
		x=demoState
		tmp=a=overscan_lo,x tmp+1=a=overscan_hi,x
		goto (tmp)
		
overscanEnd:		
		nocross{overscan_end}

		/**************************************************
		 * VBlank
		 **************************************************/
		
		vblank_start

		x=demoState
		tmp=a=vblank_lo,x tmp+1=a=vblank_hi,x
		goto (tmp)
		
vblankEnd:

		a=demoState ==goto .afterDoScroll
		do_scroll a&?scr_cnt <0{do_scroll}
.afterDoScroll:

		COLUBK=a=0
		nocross{vblank_end}
		
		/**************************************************
		 * Visible screen
		 **************************************************/

		/* Rubber cube */

		TIM64T=a=198
		wsync hmove COLUBK=a=0x94
	
		// jmp to correct kernel
		x=demoState
		tmp=a=kernel_lo,x tmp+1=a=kernel_hi,x
		goto (tmp)

kernelEnd:
		// No more hmoves: enable ball
		ENABL=a=[OBJ_ENABLE] COLUPF=a=0

		nocross{timwait}
		
		/* Scroller */

		// Create scroll text
		wsync TIM64T=a=27

		COLUBK=a=0x0a COLUP0=COLUP1=a=0x90 wsync COLUBK=a

		create_scroller
		
		nocross{timwait}

		// Show_scroller
		TIM64T=a=40 //41
		// Don't do scroller and music during initial pause
		a=demoState ==goto afterMusic
		
		goto show_scroller_trampoline_enter
afterShowScroller:

		// Play music
		goto music_enter
afterMusic:
		
		nocross{timwait}

	} always
		
}
