/*
 * OPTIMIZE:
 * - RAM: Use p0_xLo and later as tmp vars for constructing bytecode (pt_first, ...)
 * - RAM: merge _xAdd and _xAddPlus1
 * - Speed: inline lines_proclines; fetch values like pos of first point only once
 * - Speed: Kernel: In reposition store, instead of "x=a ... a=x", store a first and then jmp out later
 * - RAM: Re-use some vars that can be set each frame anew, like lines_num_copies
 * - Size: Re-use code for advance pentagram routines, and hearts, and star
 * - Size: In lines_create_bytecode->copy parameters, .m0Size is not needed for speed and can be size-reduced
 * - Size: Some coords in star.k65 are the same in all instances, like "35" for x[0]
 * - Size: (Maybe) For sorted init in advance_ subroutines, copy table instead of lda/sta (fast enough?)
 * - Size: Height of border gfx? Bottom the same?
 * - Speed: procLine: repos=a=0 in easy case needed?
 * - Speed: Sanitize:  a+0; pt,x=a -> inc pt,x
 */

[
	STATE_LINES_START = 0,
	STATE_LINES_STAR_SWING = 1,
	STATE_LINES_STAR_BOUNCE_1 = 2,
	STATE_LINES_STAR_BOUNCE_2 = 3,
	STATE_LINES_PENTA_1 = 4,
	STATE_LINES_PENTA_2 = 5,
	STATE_LINES_TWISTER = 6,
	STATE_LINES_TWISTER_TEXT_1 = 7,
	STATE_LINES_TWISTER_TEXT_2 = 8,
	STATE_LINES_HEARTS_1 = 9,
	STATE_LINES_HEARTS_2 = 10,
	STATE_LINES_HEARTS_3 = 11,
	STATE_LINES_END = 12
]

[
	MAX_POINTS = 10
]

var pts_num=0x84 ?;		// Set to num-1
var pts_sorted[MAX_POINTS] ?;
var pts_xPos[MAX_POINTS] ?, pts_yPos[MAX_POINTS] ?;
var pt_first ?, pt_firstXPos ?, pt_second ?, pts_dirFlag ?, pt_objType ?;
var pt_firstYPos ?, pt_firstPXpos ?, pt_firstPYpos ?;
var lines_activeObjects ?;
var m0_xLo ?, m0_xAddLo ?, m0_xAdd ?, m0_xAddPlus1 ?, m0_dy ?, m0_count ?, m0_repos ?;
var m1_xLo ?, m1_xAddLo ?, m1_xAdd ?, m1_xAddPlus1 ?, m1_dy ?, m1_count ?, m1_repos ?;
var p0_xLo ?, p0_xAddLo ?, p0_xAdd ?, p0_xAddPlus1 ?, p0_dy ?, p0_count ?, p0_repos ?;
var p1_xLo ?, p1_xAddLo ?, p1_xAdd ?, p1_xAddPlus1 ?, p1_dy ?, p1_count ?, p1_repos ?;
var lines_num_copies ?;
var pts_byteCode[40] ?;
var lines_varend ?;	// imperical after debugging: until 0xec inclusive


/* Calc fade-in color index according to numFrame.
 * IN: a=max index
 * OUT: x=index
 * trashes tmp
 */
func lines_calc_fade_in {
	tmp=a
	a=numFrame a>> a>> a?tmp >={a=tmp}
	x=a
}


/* Calc fade-out color index according to numFrame.
 * IN: a=max index
 * OUT: x=index
 * trashes tmp
 */
func lines_calc_fade_out {
	tmp=a
	x=demoState a=lines_durations,x c+ a-numFrame
	a>> a>> a?tmp >={a=tmp}
	x=a
}


/* Waste x scanlines.
 */
func lines_waste {
	{wsync x--}!=
}


/* Empty, dummy display kernel
 */
func lines_kernel_nothing {
}


/* Fine-position object.
 * a: position (0..159)
 * x: object number
 * Does not do the necessary HMOVE, only prepares HM register.
 */
func lines_pos_object {
	wsync lines_kernel_nothing *2 c+ nocross{a-15}>= RESP0,x=a
	a^7 a<< a<< a<< a<< HMP0,x=a
}


/* Prepare and position objects for lines kernel.
 */
func lines_prepare_objects {
	// TODO: What if no players?

	// Position objects
	NUSIZ0=NUSIZ1=x=0
	a=pt_firstPXpos lines_pos_object
	x++ a=pt_firstPXpos lines_pos_object
	y=pts_sorted a=pts_xPos,y x++ lines_pos_object
	a=pts_xPos,y x++ lines_pos_object
	wsync hmove
	// Init number of objects
	a=4 x=pt_firstPXpos =={a=2} lines_activeObjects=a
	// Calc player distance from top m0 point
	a=pt_firstPYpos c+ a-pts_yPos,y	// cannot be 0 (sanitized)
	p0_count=a p1_count=a
	// Set initial NUSIZ
	NUSIZ0=a=m0_xLo NUSIZ1=a=m1_xLo
	// Reset HM regs
	HMCLR=a
	
	// Init kernel vars
	m0_xLo=m1_xLo=a=0
	p0_xAddLo=a p0_repos=a p0_xAdd=a
	p1_xAddLo=a p1_repos=a p1_xAdd=a
}


/* Display lines kernel.
 * Trashes tmp, lines_activeObjects
 * TODO:
 * - ?Disable object on new line; enable all objects after hmove
 */
func lines_kernel {
	// Waste lines depending on top point
	y=pts_sorted x=pts_yPos,y x++ lines_waste

	// Prepare stack pointer
	tmp=x=s s=x=&<pts_byteCode-1
	
	// Start kernel by enabling all objects
	y=0
	wsync ENAM0=ENAM1=a=[OBJ_ENABLE]
	{
		////////// M0 ////////////////////////////////////////
		// Do movement
		a=m0_xLo c+ a-m0_xAddLo
		// Check for underflow and set x to xAdd/xAddPlus1 accordingly
		x=m0_xAdd <{ a+m0_dy x=m0_xAddPlus1 }
		m0_xLo=a HMM0=x
		// Do potential new line
		m0_count-- =={
			// New line: check if we have to reposition first
			a=m0_repos !={
				wsync lines_kernel_nothing *3 c+ nocross{a-15}>= RESM0=a	// fine-pos
				a^7 a<< a<< a<< a<< HMM0=a
				m0_repos=y
			}
			// Process byte code for new line
			a?? == {
				// End of lines for this object: Disable
				m0_xAddLo=ENAM0=a
				lines_activeObjects--
			} else {
				// Prepare new line
				m0_xAdd=a a<< a<< a<< a<< m0_xAddPlus1=a	// xAddHi
				a?? m0_xAddLo=a								// xAddLo
				a??	<0{										// dy, maybe reposition
					a&0b01111111 m0_dy=m0_count=a			// mask re-pos bit to get real dy
					a?? m0_repos=a !=goto .m0Size			// get and store new xpos, for next node
				}
				m0_dy=m0_count=a
.m0Size:
				a?? NUSIZ0=a								// size
				m0_xLo=y
			}
		}

		////////// M1 ////////////////////////////////////////
		// Do movement
		a=m1_xLo c+ a-m1_xAddLo
		// Check for underflow and set x to xAdd/xAddPlus1 accordingly
		x=m1_xAdd <{ a+m1_dy x=m1_xAddPlus1 }
		m1_xLo=a HMM1=x
		// Do potential new line
		m1_count-- =={
			// New line: check if we have to reposition first
			a=m1_repos !={
				wsync lines_kernel_nothing *3 c+ nocross{a-15}>= RESM1=a	// fine-pos
				a^7 a<< a<< a<< a<< HMM1=a
				m1_repos=y
			}
			// Process byte code for new line
			a?? == {
				// End of lines for this object: Disable
				m1_xAddLo=ENAM1=a
				lines_activeObjects--
			} else {
				// Prepare new line
				m1_xAdd=a a<< a<< a<< a<< m1_xAddPlus1=a	// xAddHi
				a?? m1_xAddLo=a								// xAddLo
				a??	<0{										// dy, maybe reposition
					a&0b01111111 m1_dy=m1_count=a			// mask repos bit to get real dy
					a?? m1_repos=a !=goto .m1Size			// get and store new xpos, for next node
				}
				m1_dy=m1_count=a
.m1Size:
				a?? NUSIZ1=a								// size
				m1_xLo=y
			}
		}

		////////// P0 ////////////////////////////////////////
		// Do movement
		a=p0_xLo c+ a-p0_xAddLo
		// Check for underflow and set x to xAdd/xAddPlus1 accordingly
		x=p0_xAdd <{ a+p0_dy x=p0_xAddPlus1 }
		p0_xLo=a HMP0=x
		// Do potential new line
		p0_count-- =={
			// New line: check if we have to reposition first
			a=p0_repos !={
				wsync lines_kernel_nothing *3 c+ nocross{a-15}>= RESP0=a	// fine-pos
				a^7 a<< a<< a<< a<< HMP0=a
				p0_repos=y
			}
			// Process byte code for new line
			a?? == {
				// End of lines for this object: Disable
				p0_xAddLo=GRP0=a
				lines_activeObjects--
			} else {
				// Prepare new line
				p0_xAdd=a a<< a<< a<< a<< p0_xAddPlus1=a	// xAddHi
				a?? p0_xAddLo=a								// xAddLo
				a??	<0{										// dy, maybe reposition
					a&0b01111111 p0_dy=p0_count=a			// mask repos bit to get real dy
					a?? p0_repos=a !=goto .p0Size			// get and store new xpos, for next node
				}
				p0_dy=p0_count=a
.p0Size:
				a?? GRP0=a									// size
				p0_xLo=y
			}
		}

		////////// P1 ////////////////////////////////////////
		// Do movement
		a=p1_xLo c+ a-p1_xAddLo
		// Check for underflow and set x to xAdd/xAddPlus1 accordingly
		x=p1_xAdd <{ a+p1_dy x=p1_xAddPlus1 }
		p1_xLo=a HMP1=x
		// Do potential new line
		p1_count-- =={
			// New line: check if we have to reposition first
			a=p1_repos !={
				wsync lines_kernel_nothing *3 c+ nocross{a-15}>= RESP1=a	// fine-pos
				a^7 a<< a<< a<< a<< HMP1=a
				p1_repos=y
			}
			// Process byte code for new line
			a?? == {
				// End of lines for this object: Disable
				p1_xAddLo=GRP1=a
				lines_activeObjects--
			} else {
				// Prepare new line
				p1_xAdd=a a<< a<< a<< a<< p1_xAddPlus1=a	// xAddHi
				a?? p1_xAddLo=a								// xAddLo
				a??	<0{										// dy, maybe reposition
					a&0b01111111 p1_dy=p1_count=a			// mask repos bit to get real dy
					a?? p1_repos=a !=goto .p1Size			// get and store new xpos, for next node
				}
				p1_dy=p1_count=a
.p1Size:
				a?? GRP1=a							// size
				p1_xLo=y
			}
		}


		// For all objects: hmove, then loop
		wsync hmove
		a=lines_activeObjects =={goto AfterLinesKernel}
	}always
	
	AfterLinesKernel:
	wsync ENAM0=ENAM1=GRP0=GRP1=y

	// Restore stack pointer
	s=x=tmp
}


/* Sort indices in pts_sorted so that pts_yPos is sorted in ascending
 * order. Number of points (-1) is in pts_num.
 */
func lines_sort {
	tmp2=a=0xff		// bit 6 set so it can be used for setting v flag
	tmp=x=pts_num {
		a&?tmp2		// Sets v flag; flag if this pass has swapped something
		x=0 {
			y=pts_sorted,x a=pts_yPos,y y=pts_sorted+1,x a?pts_yPos,y >={
				a=pts_sorted,x pts_sorted,x=y pts_sorted+1,x=a
				o-	// Clear v flag: Swap has occured
			}
			x++ x?tmp
		}!=
		<<=break	// Exit loop if no swap has occured this pass: Sorted!
		tmp--
	}!=
}


/* Advance star pattern.
 */
func lines_advance_star {

	a=numFrame =={
		// Init sorted table
		pts_num=x=9 {
			pts_sorted,x=a=lines_presorted_star,x
			x--
		}>=0
		// Init rest
		lines_num_copies=a=[ONE_COPY]
	}

	// Calc x sine pos
	a=numFrame c- a+64 a>> a&127 x=a a=sine_128_64,x c- a+12 tmp=a
	y=40 x=0 {	// 40 = anim state #5
		a=lines_star_x,y c- a+tmp pts_xPos,x=a
		a=lines_star_y,y pts_yPos,x=a
		y++ x++ x?10
	}!=

star_setColors:
	// Fade background
	a=4 x=demoState x?[STATE_LINES_START] =={
		lines_calc_fade_in
	} else {
		x?[STATE_LINES_STAR_BOUNCE_2] =={
			lines_calc_fade_out
		} else {
			x=a
		}
	}
	COLUBK=a=lines_star_fade_bk,x
	// Fade star
	a=6 x=demoState x?[STATE_LINES_STAR_SWING] =={
		lines_calc_fade_in
	} else {
		x?[STATE_LINES_STAR_BOUNCE_2] =={
			lines_calc_fade_out
		} else {
			x=a
		}
	}
	COLUP0=COLUP1=a=lines_star_fade_p,x
}


/* Advance bouncing star pattern.
 */
func lines_advance_star2 {

/*
	a=numFrame =={
		// Init sorted table
		pts_num=x=9 {
			pts_sorted,x=a=lines_presorted_star,x
			x--
		}>=0
		// Init rest
		lines_num_copies=a=[ONE_COPY]
	}
*/

	// Calc star point parameters based on numFrame
	y=40
	a=numFrame a&0b00110000 a?0b00010000 !={
		a=numFrame a?16 >={
			a&0b00001110 tmp=a a<< a<< c- a+tmp y=a
		}
	}
	// Calc bounce height
	a=numFrame a&63 x=a tmp=a=lines_star_bounce,x
	// Calc x sine pos
	a=numFrame a>> a&127 x=a a=sine_128_64,x c- a+12 tmp2=a	
	x=0 {
		a=lines_star_x,y c- a+tmp2 pts_xPos,x=a
		a=lines_star_y,y c- a+tmp pts_yPos,x=a
		y++ x++ x?10
	}!=
	
	goto star_setColors
}


/* Helper function to generate pentagram coordinates
 * IN: a=x offset
 * Trashes tmp
 */
func lines_generate_penta {
	tmp=a
	a=numFrame pts_num=x=4 {
		a&127 y=a a=sine_128_64,y c- a+tmp pts_xPos,x=a
		a=y c- a+32 a&127 y=a	// +pi/2
		a=sine_128_64,y c- a+10 pts_yPos,x=a
		a=y c- a+19	// overall: +2*(128/5)
		x--
	}>=0
	// Fade pentagram
	a=4 x=demoState x?[STATE_LINES_PENTA_1] =={
		lines_calc_fade_out
	} else {
		x?[STATE_LINES_PENTA_2] =={
			lines_calc_fade_in
		} else {
			x=a
		}
	}
	tmp=x a=4 c+ a-tmp x=a
	COLUP0=COLUP1=a=lines_penta_fade,x
	// Fade background
	a=4 x=demoState x?[STATE_LINES_PENTA_1] =={
		lines_calc_fade_in
	} else {
		x?[STATE_LINES_PENTA_2] =={
			lines_calc_fade_out
		} else {
			x=a
		}
	}
	COLUBK=a=lines_penta_fade,x
}


/* Advance pentagram line pattern.
 */
func lines_advance_pentagram1 {

	a=numFrame =={
		// Init sorted table
		x=4 {
			a=x pts_sorted,x=a
			x--
		}>=0
		// Init rest
//		lines_num_copies=a=[ONE_COPY]
	}
	
	a=44 lines_generate_penta
}


/* Advance 2 pentagram line pattern.
 */
func lines_advance_pentagram2 {

/*
	a=numFrame =={
		// Init sorted table
		x=4 {
			a=x pts_sorted,x=a
			x--
		}>=0
	}
*/

	lines_num_copies=a=[TWO_COPIES_WIDE]
	
	a=12 lines_generate_penta
}


/* Helper function to init heart
 */
func lines_init_heart {
	// Init sorted table
	pts_num=x=9 {
		pts_sorted,x=a=lines_presorted_heart,x
		x--
	}>=0
}


/* Helper function to generate heart coordinates
 * IN: a=x offset
 * trashes tmp, tmp2
 */
func lines_generate_heart {
	tmp2=a
	a=numFrame a&31 x=a a=lines_heart_beat,x
	a<< tmp=a a<< a<< c- a+tmp y=a
	x=0 {
		a=lines_heart_x,y c- a+tmp2 pts_xPos,x=a
		a=lines_heart_y,y c- a+16 pts_yPos,x=a
		y++ x++ x?10
	}!=	
	
lines_heart_fade:
	// Fade background
	a=7 x=demoState x?[STATE_LINES_HEARTS_1] =={
		lines_calc_fade_in
	} else {
		x?[STATE_LINES_HEARTS_3] =={
			lines_calc_fade_out
		} else {
			x=a
		}
	}
	x=a a<<	COLUBK=a
	// Fade heart
	a=numFrame a?80 <{
		// Fade in
		a=5 lines_calc_fade_in
		a=demoState a?[STATE_LINES_HEARTS_1] =={
			COLUP0=COLUP1=a=lines_heart_fade_black,x
		} else {
			COLUP0=COLUP1=a=lines_heart_fade_white,x			
		}
	} else {
		// Fade out
		a=5 lines_calc_fade_out
		a=demoState a?[STATE_LINES_HEARTS_3] =={
			COLUP0=COLUP1=a=lines_heart_fade_black,x
		} else {
			COLUP0=COLUP1=a=lines_heart_fade_white,x			
		}
	}
}


/* Advance 1 heart line pattern.
 */
func lines_advance_heart {

	a=numFrame =={
		lines_init_heart
		// Init rest
		lines_num_copies=a=[ONE_COPY]
	}

	// Figure
	a=39 lines_generate_heart
}


/* Advance 2 hearts line pattern.
 */
func lines_advance_heart2 {

/*
	a=numFrame =={
		lines_init_heart
		// Init rest
		lines_num_copies=a=[TWO_COPIES_WIDE]
	}
*/

	lines_num_copies=a=[TWO_COPIES_WIDE]
	// Figure
	a=12 lines_generate_heart
}


/* Advance 3 heart2 line pattern.
 */
func lines_advance_heart3 {

/*
	a=numFrame =={
		lines_init_heart
		// Init rest
		lines_num_copies=a=[THREE_COPIES_MEDIUM]
	}
*/

	lines_num_copies=a=[THREE_COPIES_MEDIUM]

	// Figure
	a=numFrame a&31 x=a a=lines_heart_beat,x
	a<< tmp=a a<< a<< c- a+tmp y=a
	x=0 {
		a=lines_heart3_x,y c- a+12 pts_xPos,x=a
		a=lines_heart3_y,y pts_yPos,x=a
		y++ x++ x?10
	}!=
	
	goto lines_heart_fade
}


/* Empty advance function
 */
func lines_advance_nothing {
	// Dummy values so sort etc. won't crash
	pts_num=a=2
	pts_xPos+0=a
	pts_xPos+1=a
	pts_xPos+2=a
	pts_yPos+0=a
	pts_yPos+1=a
	pts_yPos+2=a
	
	goto star_setColors
}


/* Helper function to init twister
 */
func lines_init_twister {
	// Init sorted table
	pts_num=x=9 {
		pts_sorted,x=a=lines_presorted_twister,x
		pts_yPos,x=a=lines_twister_yPos,x
		x--
	}>=0
}


/* Advance twister line pattern
 */
func lines_advance_twister {
	a=numFrame =={
		// Init sorted table
		lines_init_twister
		// Init rest
		lines_num_copies=a=[THREE_COPIES_MEDIUM]
	}

	// xPos
	a=numFrame
	
	a&127 x=a pts_xPos+0=y=sine_128_64,x
	c- a+64 a&127 x=a pts_xPos+5=y=sine_128_64,x
	
	c- a+40 a&127 x=a pts_xPos+6=y=sine_128_64,x
	c- a+64 a&127 x=a pts_xPos+1=y=sine_128_64,x

	c- a+40 a&127 x=a pts_xPos+2=y=sine_128_64,x
	c- a+64 a&127 x=a pts_xPos+7=y=sine_128_64,x
	
	c- a+40 a&127 x=a pts_xPos+8=y=sine_128_64,x
	c- a+64 a&127 x=a pts_xPos+3=y=sine_128_64,x
	
	c- a+40 a&127 x=a pts_xPos+4=y=sine_128_64,x
	c- a+64 a&127 x=a pts_xPos+9=y=sine_128_64,x
	
	x=9 {
		a=pts_xPos,x c- a+16 pts_xPos,x=a
		x--
	}>=0
	
	// Fade background
	a=3 x=demoState x?[STATE_LINES_TWISTER] =={
		lines_calc_fade_in
	} else {
		x?[STATE_LINES_TWISTER_TEXT_2] =={
			lines_calc_fade_out
		} else {
			x=a
		}
	}
	x=a a<<	COLUBK=a
	// Fade twister
	a=8 x=demoState x?[STATE_LINES_TWISTER] =={
		lines_calc_fade_in
	} else {
		x?[STATE_LINES_TWISTER_TEXT_2] =={
			lines_calc_fade_out
		} else {
			x=a
		}
	}	
	COLUP0=COLUP1=a=lines_twister_fade_p,x
}


/* Make sure no two points have the same y coordinate.
 * Expects points to be sorted already.
 */
func lines_sanitize {
	x=pts_sorted a=pts_yPos,x y=0 {
		x=pts_sorted+1,y a?pts_yPos,x >={a+0 pts_yPos,x=a}
		a=pts_yPos,x
		y++ y?pts_num 
	}!=
}


/* Divide a>0 by tmp>0, to a max of 6. Result in x, remainder in a.
 * Returns 6/255 if >6.
 * Trashes tmp, but not y.
 * OPTIMIZE:
 * - Move a+tmp to caller (what if 255? Should be no problem)
 */
inline lines_div {
	c+
	a-tmp <{a+tmp x=0 ==goto .after}
	a-tmp <{a+tmp x=1 !=goto .after}
	a-tmp <{a+tmp x=2 !=goto .after}
	a-tmp <{a+tmp x=3 !=goto .after}
	a-tmp <{a+tmp x=4 !=goto .after}
	a-tmp <{a+tmp x=5 !=goto .after}
	a-tmp <{a+tmp x=6 !=goto .after}
	x=6 a=255
.after:
}


/* Create bytecode for one line.
 * IN:
 * y: index into pts_byteCode
 * pt_first: Index of first point
 * x: Index of second point. Must be below first point!
 * pt_objType: >=0 for missile, <0 for player object
 * 
 * Trashes tmp, tmp2
 * Re-uses p1_repos
 * 
 * OPTIMIZE:
 * - Re-use vars
 * - Instead of first obj type check: set x to 0 and jmp to second check
 * - Do different funcs for missiles and objects, to avoid if checks
 */
func lines_procline {
	/* Bytecode format:
	 *     xAddHi: 7..4 xadd_hi, 3..0 xadd_+1, or 0 if end of object is reached
	 *     xAddLo: 0..dy
	 *     dy: 0..127; bit 7 is set for reposition. In that case, next byte is xpos
	 *     size: NUSIZ or GRP value
	 */
	pt_second=x									// save index of second point for later
	// dy
	x=pt_first tmp=a=pts_yPos,x					// tmp=ypos of top point
	pt_firstXPos=a=pts_xPos,x					// pt_firstXPos=xpos of top point, for later use
	x=pt_second a=pts_yPos,x c+ a-tmp			// a=dy (cannot be 0, as sanitized already)
	pts_byteCode+2,y=a							// store dy
	// dx
	pts_dirFlag=a=0								// init direction flag with dx>0 to 0="go right"
	a=pts_xPos,x p1_repos=a						// Fetch second xpos and store for later
	c+ a-pt_firstXPos							// calc dx
	<{											// dx<0:
		a^0xff a+1								// dx=-dx (carry is clear)
		pts_dirFlag--							// set dir flag to 0xff="go left"
	}
	// a now contains abs(dx)
	// Test if dx<dy
	a?pts_byteCode+2,y
	<{											// dx<dy
		// dx<dy: Size 1, easy case
		pts_byteCode+1,y=a						// xAddLo=dx
		a=0x0f a&?pts_dirFlag <0{a=0x01}		// Set to step 0+1, direction depending on flag
		pts_byteCode,y=a						// Store xAddHi
		a&?pt_objType >=0{						// Size type depends on object type
			// missile
			a=[MSL_SIZE_1] a|lines_num_copies pts_byteCode+3,y=a
		} else {
			// player
			pts_byteCode+3,y=a=0b10000000
		}
		// TODO: Needed?
		p1_repos=a=0							// No repos byte emitting needed
	} else {									// dx>=dy
		// dx>=dy: Compute size: dx/dy
		tmp=x=pts_byteCode+2,y lines_div
		// Now x holds result, a remainder
		pts_byteCode+1,y=a						// xAddLo=remainder
		// Check for "overflow"
		a?255 !={
			// No re-pos byte has to be emitted
			p1_repos=a=0
		}
		// Set xAddHi according to direction
		a&?pts_dirFlag >=0{
			pts_byteCode,y=a=lines_xAdd_right,x
		} else {
			pts_byteCode,y=a=lines_xAdd_left,x
		}
		// Check if we have to emit a re-pos byte
		a=p1_repos !={
			pts_byteCode+3,y=a					// Emit new xpos
			// Set re-pos flag
			a=pts_byteCode+2,y a|0b10000000 pts_byteCode+2,y=a
			y++									// Account for extra byte
		}
		// Set size
		a&?pt_objType >=0{						// Size type depends on object type
			// missile
			a=lines_m_sizes,x a|lines_num_copies pts_byteCode+3,y=a
			//pts_byteCode+3,y=a=lines_m_sizes,x
		} else {
			// player
			pts_byteCode+3,y=a=lines_p_sizes,x
		}
	}
	y++ y++ y++ y++
}
// Size tables for missiles and players.
data lines_m_sizes { 0b00000000 0b00010000 0b00010000 0b00100000 0b00100000 0b00100000 0b00100000 }	
data lines_p_sizes { 0b10000000 0b11000000 0b11100000 0b11110000 0b11111000 0b11111100 0b11111110 }
// HM tables for xAddHi
data lines_xAdd_right {0x0f 0xfe 0xed 0xdc 0xcb 0xba 0xa9}
data lines_xAdd_left {0x01 0x12 0x23 0x34 0x45 0x56 0x67}


/* Clear all object flag data (i.e., set to 0=not yet processed).
 * Re-uses p0_xLo and later addresses!
 */
func lines_clearObjFlags {
	a=0
	p0_xLo+0=a
	p0_xLo+1=a
	p0_xLo+2=a
	p0_xLo+3=a
	p0_xLo+4=a
	p0_xLo+5=a
	p0_xLo+6=a
	p0_xLo+7=a
	p0_xLo+8=a
	p0_xLo+9=a
}


/* Create new line from current point to x.
 * Re-uses p1_count, p0_xLo+0...9
 */
inline lines_createLine {
	p1_count++						// Note that a line was created
	p0_xLo,x=a=pt_objType			// Set destination object type
	lines_procline
}


/* Convert y-sorted list of points/lines to kerneÄº bytecode.
 * Trashes tmp, tmp2, lines_activeObjects.
 * Uses p0_xLo,x for object type (reached/not reachted; missile/player)
 */
func lines_create_bytecode {
	lines_clearObjFlags
		 
	// Construct m0 (predecessor) and m1 (successor) starting from top point
	pt_objType=a=1						// Obj type: missile
	pt_first=x=pts_sorted				// Index of first point, for both m0 and m1

	// m0
	x-- <0{x=pts_num}					// index of predecessor
	p0_xLo,x=a=1						// Set object type to "reached; missile"
	y=0 m0_repos=m1_repos=y				// also: y=index into byte code
	lines_procline
	// copy parameters
	a=pts_byteCode+0
	m0_xAdd=a a<< a<< a<< a<< m0_xAddPlus1=a	// xAddHi
	m0_xAddLo=a=pts_byteCode+1
	y=3 a=pts_byteCode+2 <0{						// dy, maybe reposition
		a&0b01111111 m0_dy=m0_count=a			// mask re-pos bit to get real dy
		a=pts_byteCode+3 y++
		m0_repos=a !=goto .m0Size				// get and store new xpos, for next node
	}
	m0_dy=m0_count=a
.m0Size:
	a=pts_byteCode,y a|lines_num_copies m0_xLo=a	// use m0_xLo for NUSIZ tmp store
	y=0										// reset byte code pointer (y)
	
	// m1
	x=pt_first x?pts_num =={x=0xff} x++	// index of successor
	p0_xLo,x=a=1						// Set object type to "reached; missile"
	lines_procline
	// copy parameters
	a=pts_byteCode+0
	m1_xAdd=a a<< a<< a<< a<< m1_xAddPlus1=a	// xAddHi
	m1_xAddLo=a=pts_byteCode+1
	y=3 a=pts_byteCode+2 <0{						// dy, maybe reposition
		a&0b01111111 m1_dy=m1_count=a			// mask re-pos bit to get real dy
		a=pts_byteCode+3 y++
		m1_repos=a !=goto .m1Size			// get and store new xpos, for next node
	}
	m1_dy=m1_count=a
.m1Size:
	a=pts_byteCode,y a|lines_num_copies m1_xLo=a	// use m1_xLo for NUSIZ tmp store
	y=0										// reset byte code pointer (y)
	
	// Construct rest of lines. Sweep over point index 1...num-1
	pt_firstPXpos=pt_firstPYpos=a=0		// Clear first player pos
	lines_activeObjects=x=1 {
		// Save index and ypos for later
		pt_first=a=pts_sorted,x x=a pt_firstYPos=a=pts_yPos,x
		// Test for object type or new lines
		a=p0_xLo,x	=={
			// Not yet reached: Player objects start here
			pt_objType=a=0xff			// player type
			// Note pos of first player
			pt_firstPXpos=a=pts_xPos,x
			pt_firstPYpos=a=pt_firstYPos
		} else {
			// Set object type for lines
			pt_objType=a
		}
		// Init "created new lines" flag
		p1_count=a=0
		// Predecessor
		x-- <0{x=pts_num}
		a=pts_yPos,x a?pt_firstYPos >={
			lines_createLine
		}
		// Successor
		x=pt_first x?pts_num =={x=0xff} x++
		a=pts_yPos,x a?pt_firstYPos >={	
			lines_createLine
		}
		// Check if no new lines were created
		a=p1_count =={
			// End point: Emit two zeros as "end line" markers
			pts_byteCode,y=a y++ pts_byteCode,y=a y++
		}
		// Next
		lines_activeObjects++ x=lines_activeObjects x?pts_num
	}!=
	// Mark end of last two lines
	pts_byteCode,y=a=0 pts_byteCode+1,y=a
}


/* Display bottom PF border: Slope
 */
func lines_bottom_slope {
	// Fade background and switch from ball to PF
	a=3 x=demoState x?[STATE_LINES_HEARTS_1] =={
		lines_calc_fade_in
	} else {
		x?[STATE_LINES_HEARTS_3] =={
			lines_calc_fade_out
		} else {
			x=a
		}
	}
	a=x a<<
	wsync hmove ENABL=x=0
	COLUPF=a
	// Display slope
	x=18 nocross {
		wsync hmove
		PF0=a=border_slope_1,x
		PF1=a=border_slope_2,x
		PF2=a=border_slope_3,x
		sl10
		PF0=a=border_slope_4,x
		sl4
		PF1=a=border_slope_5,x
		sl5
		PF2=a=border_slope_6,x
		x--
	}>=0
	wsync hmove PF0=PF1=PF2=x
	x=11 { wsync hmove x-- }>=0
}


/* Display bottom PF border: Graves
 */
func lines_bottom_graves {
	wsync hmove ENABL=a=0 COLUPF=a=0x00
	x=31 nocross {
		wsync hmove
		PF0=a=border_penta_1,x
		PF1=a=border_penta_2,x
		PF2=a=border_penta_3,x
		sl10
		PF0=a=border_penta_4,x
		sl4
		PF1=a=border_penta_5,x
		sl5
		PF2=a=border_penta_6,x
		x--
	}>=0
	wsync hmove PF0=PF1=PF2=x
}


/* Display bottom PF border: Twister
 */
func lines_bottom_twister {
	// Fade lower background color
	a=7 x=demoState x?[STATE_LINES_TWISTER] =={
		lines_calc_fade_in
	} else {
		x?[STATE_LINES_TWISTER_TEXT_2] =={
			lines_calc_fade_out
		} else {
			x=a
		}
	}
	a=x a<<
	wsync
	COLUBK=a
	// Fade sprite color
	a=demoState a?[STATE_LINES_TWISTER_TEXT_1] =={
		a=6 lines_calc_fade_in
		COLUP0=COLUP1=a=lines_twister_fade_text_in,x
	} else {
		a?[STATE_LINES_TWISTER_TEXT_2] =={
			a=4 lines_calc_fade_out
			COLUP0=COLUP1=a=lines_twister_fade_text_out,x
		} else {
			COLUP0=COLUP1=a=0x94
		}
	}
	
	// Init 48 pix sprite
	wsync
	VDELP0=VDELP1=a=[VDEL_ENABLE]				// 8
	NUSIZ0=NUSIZ1=a=[THREE_COPIES_CLOSE]		// 8
	HMP0=a=[HM_NO_MOTION] HMP1=a=[HM_LEFT_1]	// 10
	a=demoState a?[STATE_LINES_TWISTER] !={
		*3 lines_kernel_nothing
		// @48
		RESP0=a RESP1=a
		wsync
		hmove
		
		// Loop
		tmp=y=27 nocross {
			wsync
			y=tmp							// 3
			GRP0=a=motck_1,y				// 7
			GRP1=a=motck_2,y				// 7
			GRP0=a=motck_3,y				// 7
			tmp2=a=motck_6,y				// 7
			a=x=motck_5,y					// 4
			a=motck_4,y						// 4
			y=tmp2							// 3
			sl11
			// @53
			GRP1=a GRP0=x GRP1=y GRP0=a
			tmp--
		}>=0
	}
	// Clean up
	VDELP0=VDELP1=a=[VDEL_DISABLE]
	GRP0=GRP1=GRP0=a	//=0

}


/* Display bottom for star figure
 * 0x98, 0x78, 0x0e, 0x3a, 0x36
 */
func lines_bottom_star {
	a=demoState a?[STATE_LINES_START] !=goto .display
	a=numFrame a?40 <goto .afterDisplay
.display:
	y=7 {
		COLUBK=a=border_trans_colors,y
		x=border_transition,y lines_waste
		y--
		wsync
	}>=0
.afterDisplay:
}


/* Main
 */
func lines_main {
	s=x=0xff

	// Init
	demoState=a=0 numFrame=x
	
	// Position ball for hmove bar hiding
	wsync RESBL=a CTRLPF=a=[BALL_SIZE_8]
	lines_kernel_nothing lines_kernel_nothing	// *24
	HMBL=a=[HM_LEFT_2] wsync hmove
	lines_kernel_nothing lines_kernel_nothing	// *24
	HMBL=a=0
	==goto LinesStart

	// Kernel
	{
		/**************************************************
		 * Overscan
		 **************************************************/
		
		overscan_start

LinesStart:

		// Script
		numFrame++
		x=demoState a=lines_durations,x !={
			a?numFrame =={
				numFrame=a=0 demoState++
				a=demoState a?[STATE_LINES_END] =={far greetings_main}
			}
		}
		
		// Advance pattern according to state
		a=&>.afterAdvance-1 a!!
		a=&<.afterAdvance-1 a!!
		x=demoState
		tmp=a=lines_advance_lo,x
		tmp+1=a=lines_advance_hi,x
		goto (tmp)
.afterAdvance:

		lines_sort
		lines_sanitize
		
		far music
		
		overscan_end


		/**************************************************
		 * VBlank
		 **************************************************/
		
		vblank_start

		lines_create_bytecode
		lines_prepare_objects		

		PF0=PF1=PF2=COLUPF=a=0
		ENABL=a=[OBJ_ENABLE]
		
		vblank_end

		
		/**************************************************
		 * Visible screen
		 **************************************************/
		
		TIM64T=a=216
		
		// Multiplex kernel according to state
		a=demoState a?[STATE_LINES_START] =={
			lines_kernel_nothing
		} else {
			lines_kernel
		}
		timwait
		
		TIM64T=a=41
		
		// bottom kernel

		a=&>.afterBottom-1 a!!
		a=&<.afterBottom-1 a!!
		x=demoState
		tmp=a=lines_bottom_lo,x
		tmp+1=a=lines_bottom_hi,x
		goto (tmp)
.afterBottom:

		timwait wsync
		
	} always
}
