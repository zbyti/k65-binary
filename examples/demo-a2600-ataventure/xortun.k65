

data PrefixXorLeft {
	align 256
	for x=0..255 eval [e=x, e=e^floor(e/2), e=e^floor(e/4), e=e^floor(e/16), e&255]
}

data PrefixXorRight {
	align 256
	for x=0..255 eval [e=x, e=e^(e*2), e=e^(e*4), e=e^(e*16), e&255]
}


inline prefix_xor {
	y=15
	{
		x=frambuff,y a=PrefixXorLeft,x frambuff,y=a
		
		a^0xFF a>>> a=0 a-0
		x=frambuff+16,y a^PrefixXorRight,x frambuff+16,y=a
		
		a^0xFF a<<< a=0 a-0
		x=frambuff+32,y a^PrefixXorLeft,x frambuff+32,y=a

		a^0xFF a>>> a=0 a-0
		x=frambuff+48,y a^PrefixXorRight,x frambuff+48,y=a

		y--
	}>=0
}


/*
	b = dx/dy
	dx = rem(dx/dy)
	pos -= dy

	pos += dx
	if(pos>=dy)
		x++, pos-=dy
	x+=b

	
	tmp1 - dx
	tmp2 - dy
	fast_div
	tmp3=a
	tmp4=a=0xFF

	
	a=pos  c- a+dx   >={ a-dy   c+ } pos=a  a=x a+b    x=a
	a=tmp4 c- a+tmp3 >={ a-tmp2 c+ } tmp4=a a=x a+tmp1 x=a

	pptr=a=PlotReg,x a=(pptr),y a^PlotBit,x (pptr),y=a
*/

func xordot_line {
	// input:
	//	x		- X
	//	y		- Y
	//	tmp1	- dx
	//	tmp2	- dy

	a=tmp2 <0{ goto xdl_y }
	=={
		a=tmp1
		<0  { goto xdl_xy_fill }
		else{ goto xdl_xY_fill }
	}

	a=tmp1 <0 goto xdl_xY


	// ---- xdl_XY ----
	fast_div tmp3=a
	a>> a^0xFF tmp4=a
	{
		a=tmp4 c- a+tmp3 >={ a-tmp2 c+ } tmp4=a a=x a+tmp1 x=a
		x?32
		>= goto xdl_XY_end

		pptr=a=PlotReg,x a=(pptr),y a^PlotBit,x (pptr),y=a
		y++
		y?16
	}<
	xdl_XY_end:
	return

	// ---- xdl_xY ----
	xdl_xY:
	a^0xFF c- a+1 tmp1=a
	fast_div tmp3=a
	a>> a^0xFF tmp4=a
	{
		a=tmp4 c- a+tmp3 >={ a-tmp2 } else { c+ } tmp4=a a=x a-tmp1 x=a
		<0 goto xdl_xY_fill

		pptr=a=PlotReg,x a=(pptr),y a^PlotBit,x (pptr),y=a
		y++
		y?16
	}<
	return
	
	xdl_xY_fill:
	x=0x80
	{
		a=x a^frambuff,y frambuff,y=a
		y++
		y?16
	}<
	return

	xdl_y:
	a^0xFF c- a+1 tmp2=a
	a=tmp1 <0 goto xdl_xy

	fast_div tmp3=a
	a>> a^0xFF tmp4=a
	y--

	// ---- xdl_Xy ----
	{
		a=tmp4 c- a+tmp3 >={ a-tmp2 c+ } tmp4=a a=x a+tmp1 x=a
		x?32
		>= goto xdl_Xy_end

		pptr=a=PlotReg,x a=(pptr),y a^PlotBit,x (pptr),y=a
		y--
	}>=0
	xdl_Xy_end:
	return

	// ---- xdl_xy ----
	xdl_xy:
	a^0xFF c- a+1 tmp1=a
	fast_div tmp3=a
	a>> a^0xFF tmp4=a
	y--
	{
		a=tmp4 c- a+tmp3 >={ a-tmp2 } else { c+ } tmp4=a a=x a-tmp1 x=a
		<0 goto xdl_xy_fill

		pptr=a=PlotReg,x a=(pptr),y a^PlotBit,x (pptr),y=a
		y--
	}>=0
	return

	xdl_xy_fill:
	x=0x80
	{
		a=x a^frambuff,y frambuff,y=a
		y--
	}>=0
}


data XorRot {
	align 128
	for x=0..127 eval [cos(x/128*2*pi)*32+256]
}

inline xortun_ray {
	// A - offset angle

	c- a+subframe	a&0x7F x=a a=XorRot,x c- a+fxpA tmp1=a
	a=x	c- a+32		a&0x7F x=a a=XorRot,x c- a+fxpB tmp2=a

	x=16 y=8
	xordot_line
}

inline fbclr_inv {
	a=0
	y=0x80
	x=7
	{
		frambuff,x=y
		frambuff+8,x=y
		frambuff+16,x=a
		frambuff+24,x=a
		frambuff+32,x=a
		frambuff+40,x=a
		frambuff+48,x=a
		frambuff+56,x=a
		x--
	}>=0
}

func fx_xortun {

	far fsync1 far song_player

	a=0  xortun_ray

	fsync2

	a=32 xortun_ray
	a=64 xortun_ray
	a=96 xortun_ray

	far fsync3
		
	prefix_xor

	{ a=INTIM a?175 }!=

	wsync
	txtc=a=0
	txtc+1=a=&>BufCol
	far drawbuffer

	a=16 c+ a-16 fxpA=a
	a=8  c+ a-8  fxpB=a
	y=0
	a=subframe c- a+1  a&0x7F x=a a=XorRot,x c- a+fxpB <0{y++}
	a=subframe c- a+65 a&0x7F x=a a=XorRot,x c- a+fxpB <0{y++}
	a=y a&1 =={ fbclr } else { fbclr_inv }

}

//inline tnox3 { a-px1 a?0x80 tmp3>>> }
//inline tnox4 { a-px1 a?0x80 tmp4>>> }
//inline tnoy5 { a-py1 a?0x80 tmp5>>> }
//inline tnoy6 { a-py1 a?0x80 tmp6>>> }
//
//func tunoff {
//	a=px0 a+px2 px0=a
//	tnox3 tnox3 tnox3 tnox3 tnox3 tnox3 tnox3 tnox3
//	tnox4 tnox4 tnox4 tnox4 tnox4 tnox4 tnox4 tnox4
//	a=py0 a+py2 py0=a
//	tnoy5 tnoy5 tnoy5 tnoy5 tnoy5 tnoy5 tnoy5 tnoy5
//	tnoy6 tnoy6 tnoy6 tnoy6 tnoy6 tnoy6 tnoy6 tnoy6
//	a=tmp3 a^tmp5 frambuff+32,x=a
//	a=tmp4 a^tmp6 frambuff,x=a
//}

data TunSin {
	align 256
	for x=0..255 eval [sin(x/256*2*pi*3)*12+256]
}

func fx_proctun {

	far fsync1 far song_player

	x=5 y=13	tunoff
	x++	y--		tunoff

	fsync2

	x=7 y=11	tunoff
	x++	y--		tunoff
	x++	y--		tunoff
	x++	y--		tunoff
	x++	y--		tunoff
	x++	y--		tunoff
	x++	y--		tunoff
	x++	y--		tunoff

	far fsync3
	wsync

	x=15 y=3	tunoff
	x++	y--		tunoff
	x++	y--		tunoff
	x++	y--		tunoff

	roto2_draw_init
	a=smallframe a&0x0F dfx1=a
	a=songpos_seq a<< a<< a<< a<<
	a|songpos_step a<< a<<
	a&0xF0 c- a+dfx1 dfx1=a 

	frambuff=a=frambuff+1
	frambuff+32=a=frambuff+33

	a=frambuff pf1=a
	a=frambuff+32 gp0=a 
	x=0xFF
	nocross {
		wsync
		scanliner3
	}<
	x++ gp0=a=frambuff+32,x
	y=4 nocross { wsync pf1=a=frambuff,x *40 pf1=a=tmp7 y-- }>=0

	a=0 gp0=a gp1=a *2 pf1=a pf2=a cbg=a

	a=demo_event
	a?4 <{
	 	a=px2 c- a+py1 py1=a
		a=subframe a&7 =={ a=px2 c- a+1 px2=a }

		a=demo_event
		a?2 <{	a=smallframe x=a a=TunSin,x a?0x80 a>>> c- a+px1 px1=a	}
		else {	a=smallframe x=a a=TunSin,x a?0x80		c- a+px1 px1=a	}
	}
	else
	{
		a=frame x=a a=TunSin,x c- a+py1 py1=a
		a=smallframe x=a a=TunSin,x c- a+px1 px1=a
	}

	x=1 y=17	tunoff
	x++	y--		tunoff
	x++	y--		tunoff
	x++	y--		tunoff
}

func seq_proctun
{
	px2=a=0;
	{
		fx_proctun
		a=demo_event a?8
	}<
	demo_event=a=0
}
