
data shiftbit {
	for x = 0 .. 7 eval [1<<x]
}

data PlotBit {
	align 32
	for x = 0 .. 7 eval [1<<(7-x)]
	for x = 0 .. 7 eval [1<<x]
	for x = 0 .. 7 eval [1<<(7-x)]
	for x = 0 .. 7 eval [1<<x]
}

data PlotReg {
	align 32
	for x = 0 .. 31 eval [10*16+floor(x/8)*16]
}


inline plot {
	// Acc	- X coord
	// tmp1	- Y coord
	
	x=a pptr=a=PlotReg,x
	y=tmp1 a=(pptr),y a|PlotBit,x (pptr),y=a



//	y=a a&7 x=a							// x = bit position
//	a=y a>> a>> a>>						// a - byte position
//	c- a+tmp1 a+tmp1 a+tmp1 a+tmp1 y=a	// y - final byte position

//	a=frambuff,y a|shiftbit,x frambuff,y=a
}

inline plotx {
	// Acc	- X coord
	// tmp1	- Y coord
	
	y=a a&7 x=a							// x = bit position
	a=y a>> a>> a>>						// a - byte position
	c- a+tmp1 a+tmp1 a+tmp1 a+tmp1 y=a	// y - final byte position

	a=frambuff,y a^shiftbit,x frambuff,y=a
}

data QIndex {
	align 128
	for x=0..127 eval [floor(x/8)]
}

func drawbuffer {
	

	//eb=a=2
	//a=subframe a<< a<< a^0xFF a&0x7F c- a+1 wsync *5 { a-15 }>=0 a<< a<< a<< a<< a^0x70 hb=a rb=a
	//wsync hmove=a *30 
	//hb=a=0x70 a=0x60
	//wsync hmove=a *18 hb=a

	// draw loop
	wsync *41
	a=0xFF pf0=a ctpf=a
	y=0 pf1=y pf2=y cpf=y
	nocross {
		*7
		x=QIndex,y
		a=(txtc),y
		// --- wsync ---
		cbg=a
		a=frambuff,x pf1=a
		a=frambuff+16,x pf2=a
		*24
		a=frambuff+32,x
		pf2=a
		a=frambuff+48,x
		pf1=a
		y++
	}>=0

	// cleanup
	wsync
	a=0 cpf=a cbg=a pf0=a pf1=a pf2=a
	eb=a
}


data BufCol {
	align 256
	for x = 0 .. 127 eval [round(cos(x/128*2*pi+pi)*3.5+3.5 + .49*sin(x*cos(x*100)) )*2+5*16]
}


data sine {
	for x = 0 .. 127 eval [sin(x/128*2*pi)*12.5+15.5]
}

data sine2 {
	for x = 0 .. 63 eval [sin(x/64*2*pi)*7.5+7.5]
}

data sine3 {
	for x = 0 .. 31 eval [sin(x/32*2*pi)*7.5+7.5]
}


func fbdown {
	x=15 {
		frambuff,x=a=frambuff-1,x
		frambuff+16,x=a=frambuff+15,x
		frambuff+32,x=a=frambuff+31,x
		frambuff+48,x=a=frambuff+47,x
		x--
	}>=0
	a=0
	frambuff+0=a
	frambuff+16=a
	frambuff+32=a
	frambuff+48=a
}

func fbleft {
	x=15 {
		c-
		frambuff+48,x>>>
		frambuff+32,x<<<
		frambuff+16,x>>>
		frambuff,x<<<
		x--
	}>=0
}

data XMask0 { align 64 for x=0..32 eval [256-(1<<(8-clamp(x- 0,0,8)))] }
data XMask1 { align 64 for x=0..32 eval [(1<<clamp(x- 8,0,8))-1] }
data XMask2 { align 64 for x=0..32 eval [256-(1<<(8-clamp(x-16,0,8)))] }
data XMask3 { align 64 for x=0..32 eval [(1<<clamp(x-24,0,8))-1] }

data XMask0n { align 64 for x=0..32 eval [(1<<(8-clamp(x- 0,0,8)))-1] }
data XMask1n { align 64 for x=0..32 eval [256-(1<<clamp(x- 8,0,8))] }
data XMask2n { align 64 for x=0..32 eval [(1<<(8-clamp(x-16,0,8)))-1] }
data XMask3n { align 64 for x=0..32 eval [256-(1<<clamp(x-24,0,8))] }

inline fbhx_draw {
	a=XMask0,x	a^frambuff,y	frambuff,y=a
	a=XMask1,x	a^frambuff+16,y	frambuff+16,y=a
	a=XMask2,x	a^frambuff+32,y	frambuff+32,y=a
	a=XMask3,x	a^frambuff+48,y	frambuff+48,y=a
}

inline fbhxn_draw {
	a=XMask0n,x	a^frambuff,y	frambuff,y=a
	a=XMask1n,x	a^frambuff+16,y	frambuff+16,y=a
	a=XMask2n,x	a^frambuff+32,y	frambuff+32,y=a
	a=XMask3n,x	a^frambuff+48,y	frambuff+48,y=a
}

func fbhalfxor_neg {
	a=tmp1 <0 goto fbhxn_xmyp

	// X+ Y+
	fbhxn_xpyp:
	{
		a=tmp3 c- a+tmp1 >=0 { { x?32 ==goto fbhxn_yp_xend x++ c+ a-tmp2 }>=0 } tmp3=a
		fbhxn_draw
		y++ y?16
	}<
	goto fbhxn_yp_done

	// X- Y+
	fbhxn_xmyp:
	{
		a=tmp3 c+ a-tmp1 >=0 { { x?0 ==goto fbhxn_yp_xend x-- c+ a-tmp2 }>=0 } tmp3=a
		fbhxn_draw
		y++ y?16
	}<
	goto fbhxn_yp_done

	fbhxn_yp_xend:
	{
		fbhxn_draw
		y++ y?16
	}<

	// done with Y+, run Y-
	fbhxn_yp_done:
	y=tmp4 y-- <0{ goto fbhxn_end }
	tmp3=a=0
	x=tmp5
	a=tmp1 <0 goto fbhxn_xmym

	// X+ Y-
	fbhxn_xpym:
	{
		a=tmp3 c- a+tmp1 >=0 { { x?0 ==goto fbhxn_ym_xend x-- c+ a-tmp2 }>=0 } tmp3=a
		fbhxn_draw
		y--
	}>=0
	goto fbhxn_end

	// X- Y-
	fbhxn_xmym:
	{
		a=tmp3 c+ a-tmp1 >=0 { { x?32 ==goto fbhxn_ym_xend x++ c+ a-tmp2 }>=0 } tmp3=a
		fbhxn_draw
		y--
	}>=0
	goto fbhxn_end

	fbhxn_ym_xend:
	{
		fbhxn_draw
		y--
	}>=0

	fbhxn_end:
}

func fbhalfxor {
	// input:
	//	X		- initial X coord
	//	Y		- initial Y coord
	//	tmp1	- direction X
	//	tmp2	- direction Y (>=0)
	//
	// temps:
	//	tmp3	- balance
	//	tmp4	- original Y value
	//	tmp5	- original X value

	tmp3=a=0
	tmp5=x
	tmp4=y
	a=tmp2 <0{ a^0xFF c- a+1 tmp2=a a=tmp1 a^0xFF c- a+1 tmp1=a goto fbhalfxor_neg }
	a=tmp1 <0 goto fbhx_xmyp
	goto fbhx_xpyp

	// X+ Y+
	{
		a=tmp3 c- a+tmp1 >=0 { { x?32 ==goto fbhx_yp_xend x++ c+ a-tmp2 }>=0 } tmp3=a
		fbhx_xpyp:
		fbhx_draw
		y++ y?16
	}<
	goto fbhx_yp_done

	// X- Y+
	{
		a=tmp3 c+ a-tmp1 >=0 { { x?0 ==goto fbhx_yp_xend x-- c+ a-tmp2 }>=0 } tmp3=a
		fbhx_xmyp:
		fbhx_draw
		y++ y?16
	}<
	goto fbhx_yp_done

	fbhx_yp_xend:
	{
		fbhx_draw
		y++ y?16
	}<

	// done with Y+, run Y-
	fbhx_yp_done:
	y=tmp4 y-- <0{ goto fbhx_end }
	tmp3=a=0
	x=tmp5
	a=tmp1 <0 goto fbhx_xmym

	// X+ Y-
	fbhx_xpym:
	{
		a=tmp3 c- a+tmp1 >=0 { { x?0 ==goto fbhx_ym_xend x-- c+ a-tmp2 }>=0 } tmp3=a
		fbhx_draw
		y--
	}>=0
	goto fbhx_end

	// X- Y-
	fbhx_xmym:
	{
		a=tmp3 c+ a-tmp1 >=0 { { x?32 ==goto fbhx_ym_xend x++ c+ a-tmp2 }>=0 } tmp3=a
		fbhx_draw
		y--
	}>=0
	goto fbhx_end

	fbhx_ym_xend:
	{
		fbhx_draw
		y--
	}>=0

	fbhx_end:
}


inline fbclr {
	a=0
	x=7
	{
		frambuff,x=a
		frambuff+8,x=a
		frambuff+16,x=a
		frambuff+24,x=a
		frambuff+32,x=a
		frambuff+40,x=a
		frambuff+48,x=a
		frambuff+56,x=a
		x--
	}>=0
}

inline fbfx1 {
	tmp1=a=15 { a=tmp1 a<< a<< c- a+subframe a&0x3F y=a a=sine,y plot tmp1-- }>=0
}

inline fbfx2 {
	tmp2=a=31 { a=tmp2 c- a+subframe a&0x3F y=a tmp1=a=sine2,y a=tmp2 plot tmp2-- }>=0
}

inline fbfx3 {
	tmp2=a=20 {
		a=tmp2 c- a+subframe a+smallframe tmp3=a a&0x3F y=a
		tmp1=x=sine2,y
		a=tmp3 c- a+smallframe a&0x7F y=a a=sine,y plot tmp2-- }>=0
}

inline fbfx4 {
	tmp2=a=20 {
		a=tmp2 c- a+subframe a+smallframe a+9 tmp3=a a&0x3F y=a
		tmp1=x=sine2,y
		a=tmp3 c- a+smallframe a+49 a&0x7F y=a a=sine,y plot tmp2-- }>=0
}

inline fbfx5 {
	tmp2=a=5 {
		a=tmp2 a<< c- a+subframe a+smallframe a+5 tmp3=a a&0x3F y=a
		tmp1=x=sine2,y
		a=tmp3 c- a+smallframe a+31 a&0x7F y=a a=sine,y plot tmp2-- }>=0
}

func fbtrail {
	nocross {
		a=tmp2 a<< a+fx_counter a+fx_data a+tmp4 tmp3=a a&0x3F y=a
		tmp1=x=sine2,y
		a=tmp3 c- a+fx_data a+tmp5 a&0x7F y=a a=sine,y plot tmp2-- }!=
}

data FxParams {
	for x=0..15 eval [0]
	for x=0..7 eval [x*8]		for x=0..7 eval [0]
	for x=0..7 eval [x*15]		for x=0..7 eval [x*15%21]
	for x=0..7 eval [0]			for x=0..7 eval [x*15]
	for x=0..7 eval [x*15]		for x=0..7 eval [0]
	for x=0..7 eval [x*20]		for x=0..7 eval [x*15%21]
	for x=0..7 eval [x*43]		for x=0..7 eval [x*19%21]
}


func morph_params {
	// A - effect ID
	a<< a<< a<< a<< c- a+15 y=a
	x=15
	{
		a=fxpA,x a?FxParams,y
		!={ <{ fxpA,x++ } else { fxpA,x-- } }
		y-- x--
	}!=
}


func fx_trails {
	far fsync1 far song_player
	fsync2

	a=1 a&?fx_counter =={ a=demo_event a&7 morph_params }
	pptr+1=a=0
	tmp2=a=2	tmp4=a=fxpA+0	tmp5=a=fxpB+0	fbtrail
	tmp2=a=2	tmp4=a=fxpA+1	tmp5=a=fxpB+1	fbtrail
	tmp2=a=2	tmp4=a=fxpA+2	tmp5=a=fxpB+2	fbtrail
	far fsync3

	x=15 { wsync x-- }>=0

	//	count		skew 1		skew 2
	tmp2=a=2	tmp4=a=fxpA+3	tmp5=a=fxpB+3	fbtrail
	tmp2=a=2	tmp4=a=fxpA+4	tmp5=a=fxpB+4	fbtrail
	tmp2=a=2	tmp4=a=fxpA+5	tmp5=a=fxpB+5	fbtrail
	txtc=a=0
	txtc+1=a=&>BufCol
	drawbuffer
}


func seq_trails {
	fx_counter=a=0 fx_data=a

	{
		fx_counter++
		a=fx_counter a&1 =={ fx_data++ }
		fx_trails

		a=demo_event
		a?4 >={
			a=demo_event a&1
			=={ fbleft } else { fbdown }
		} else {
			fbclr
		}

		a=demo_event a?8
	}<
	demo_event=a=0
}




func songdrops {

	a=tia0f fxpA=a
	a=tia1f fxpB=a

	tmp1=a=0 a=fxpA plot
	tmp1=a=1 a=fxpB plot
	drawbuffer
	fbdown
}
