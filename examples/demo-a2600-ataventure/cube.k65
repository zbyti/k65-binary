
data MvLeft  { align 8	0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 }
data MvRight { align 8	0x00 0xF0 0xE0 0xD0 0xC0 0xB0 0xA0 0x90 }

inline hposition {
	// before:	set A to X position
	// after:	h##=a r##=a
	wsync *5 { a-15 }>=0 a<< a<< a<< a<< a^0x70
}

data Cube2 {
	align 256
	10 0 30
	4 0x2F 20
	1 0x28 0xFC
	1 0x3F 1	1 0x00 0
	1 0x5F 1	1 0x00 1
	1 0x5F 1	1 0x00 2
	1 0x5F 1	1 0x00 3
	1 0x5F 1	1 0x00 4
	1 0x5F 1	1 0x00 5
	1 0x5F 1	1 0x00 6
	1 0x5F 1	1 0x00 7
	1 0x5F 1	3 0xBF 8
	1 0x5F 1	1 0x00 9
	1 0x5F 1	1 0x00 10
	1 0x5F 1	1 0x00 11
	1 0x5F 1	1 0x00 12
	1 0x5F 1	1 0x00 13
	1 0x5F 1	1 0x00 14
	1 0x5F 1	1 0x00 15
	1 0x5F 1	1 0x00 16
	1 0x5F 1	1 0x00 17
	1 0x5F 1	1 0x00 18
	1 0x5F 1	1 0x00 19
	1 0x5F 1	2 0x00 50
	1 0x5F 1	1 0x00 51
	1 0x5F 1	3 0x00 52
	1 0x5F 1	1 0x00 53	// 53 is max
	1 0x5F 1	4 0x00 44
	1 0x5F 1	1 0x00 45
	1 0x5F 1	1 0x00 46
	1 0x5F 1	1 0x00 47
	1 0x5F 1	1 0x00 48
	1 0x5F 1	1 0x00 49
	1 0x5F 1
	1 0x00 37
	1 0x6F 0xFC
	//4 0x5F 8
	//4 0x6F 0xFB
	1 0x5F 1
	1 0x6F 0xFC
	1 0x00 40
	1 0x5F 1
	1 0x6F 0xFC
	1 0x5F 5
	//5 0x6F 0xFA
	1 0x00 14
/*
	5 0x6F 0xFA
	5 0x5F 5
	5 0x6F 0xFA
	5 0x5F 5
	5 0x6F 0xFA
	5 0x5F 5
	5 0x58 5
*/
	1 0x01 0
	0
}



inline cl_dy1 {
	a?ccdy  >={ a-ccdy x++ goto cl_out } *4 goto cl_out			// always 13 & goto cl_out
}

inline cl_dy2_02 {
	a?ccdy2 >={ a-ccdy2 x=2 cl_dy1 } x=0 *2 cl_dy1				// always 12+13=25 & goto cl_out
}

inline cl_dy2_46 {
	a?ccdy2 >={ a-ccdy2 x=6 cl_dy1 } x=4 *2 cl_dy1				// always 12+13=25 & goto cl_out
}

inline cl_dy4 {
	a?ccdy4 >={ a-ccdy4 cl_dy2_46 } *2 cl_dy2_02				// always 13+25=41 & goto cr_out
}

func cube_left {
	// move left
	// startup:			26
	// last iteration:	90

	ccdx=a a=0 ccbal=a						// 8
	a=ccdy a<< ccdy2=a a<< ccdy4=a			// 13
	nocross {
		a=cccol				// 3
		wsync				// 3

		hmove=a				// 3
		cp0=a cp1=a			// 6
		x=0					// 2
		a=ccbal c- a+ccdx	// 8
		cl_dy4				// 44
		
		cl_out:
		ccbal=a				// 3
		hp0=a=MvLeft,x		// 7
		hp1=a=MvRight,x		// 7
		cchght--			// 5
	}!=						// 2 (out)
	
	goto cube_rts			// 3
}

inline cr_dy1 {
	a?ccdy  >={ a-ccdy x++ goto cr_out } *4 goto cr_out		// always 13 & goto cr_out
}

inline cr_dy2 {
	a?ccdy2 >={ a-ccdy2 x++ x++ cr_dy1 } *6 cr_dy1			// always 12+13=25 & goto cr_out
}

inline cr_dy4 {
	a?ccdy4 >={ a-ccdy4 x=4 } else { x=0 *5 } cr_dy2		// always 13+25=41 & goto cr_out
}

func cube_right {
	// move right
	// startup:			28
	// last iteration:	90

	a^0xFF ccdx=a a=0 ccbal=a
	a=ccdy a<< ccdy2=a a<< ccdy4=a
	nocross {
		a=cccol
		wsync
		hmove=a
		cp0=a cp1=a
		a=ccbal c- a+ccdx
		cr_dy4
		
		cr_out:
		ccbal=a
		hp0=a=MvRight,x
		hp1=a=MvLeft,x
		cchght--
	}!=
	
	goto cube_rts
}

func cube_blank {
	// xpos = 80 - X
	// ypos = 80 + X
	// xcrude = (80-X)/15

	cchght-- !={ { wsync x=0 cp0=x cp1=x wsync cchght-- }!= }
	tmp1=y a=poly2,y x=a tmp2=a=CubeMoveH,x
	y=CubeMoveX,x a=CubeMoveY,x c+
	!=	 { wsync x=0 cp0=x cp1=x {y--}!= rp0=a {a-1}!= rp1=a }
	else { wsync x=0 cp0=x cp1=x {y--}!= rp0=a rp1=a }
	a=tmp2 hp0=a a<< a<< a<< a<< hp1=a
	y=tmp1

	goto cube_rts
}

func cube_core {

	// run
	y=0xFF
	txtc=a=&<Cube2
	txtc+1=a=&>Cube2

	gp0=a=0 gp1=a cp0=a cp1=a
	ns0=a=7 ns1=a
	gp0=a=0xFF gp1=a
	ccc8=a=8;

	nocross {

		// ccdx		t1 - X distance
		// ccdy		t2 - Y distance
		// ccbal	t3 - balance counter
		// cchght	t4 - height counter
		// ccc8		t5 - "8" - for delay compensation compare
		// cccol	el - next color
		//
		// row format:
		//	<height>	<color>		<delta_x>
		//	<height>	0x00		<pos0>		<pos1>
		//
		y++ a=poly0,y cchght=a
		!={
			{
				// Acc,flags = dX
				ccdy=a							// 3
				a=poly1,y cccol=a				// 7
				!={								// 2 (enter)
					a=poly2,y					// 4
					<0	 { goto cube_right  }	// if:		5		(iteration = 39)
					else { goto cube_left   }	// else:	6
				} else {
					goto cube_blank
				}
				cube_rts:
				
				// loop
				y++ a=poly0,y cchght=a			// 9
			}!=									// 2 (loop)
		}
	}
	wsync
	gp0=a=0 gp1=a
}

func cube_copy_poly {

	x=0 y=0
	{
		poly0,x=a=Cube2,y y++
		poly1,x=a=Cube2,y y++
		poly2,x=a=Cube2,y y++
		x++
		x?21
	}!=
	poly0,x=a=0
}

func poly_finalize {
	a=0 tmp1=a tmp2=a
	x=0
	{
		// end check
		a=poly0,x	== goto pf_end
		
		// Y differences
		y=a
		c+ a-tmp1 poly0,x=a
		tmp1=y

		// X differences
		a=poly1,x
		== {
			// moveto
			tmp2=a=poly2,x
		} else {
			// lineto
			a=poly2,x
			y=a
			c+ a-tmp2 poly2,x=a
			tmp2=y
		}

		x++
	} always
	pf_end:
}


func main_cube {


	init
	far song_reset
	cube_copy_poly

	{ // MainLoop

		far fsync1 far song_player
		fsync2
		far fsync3
		cube_core

	} always
}
