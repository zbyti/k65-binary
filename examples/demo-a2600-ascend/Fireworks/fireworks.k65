/* Notes:
 * - Fragment data needed:
 * 	- xpos
 * 	- ypos (tmp)
 * 	- sorted
 *  - sanitizedSorted
 * 	- color (tmp)
 * - derived fragment values: TTL, xspeed, yspeed
 * - Coord bounds:
 * 	- Fragments:
 * 		- x=9..149
 * 		- y=1..71
 * 	- Rocket:
 * 		- y=1..74 (74=bottom, 1=top)
 * 		- Explode between 20 and 40, i.e. index 26 and 56, roughly 25+0..32
 * 
 * Optimize:
 * - Make fwPtr_x overlap with frag tmp vars
 * - Speed: Unroll sorting and/or sanitizing
 * - Speed: Replace most rng calls with static table lookups
 * - RAM: Re-use smth for fragSeed?
 */

[
	FW_NUM_FRAGMENTS = 18,
	FR_ROCKET_HEIGHT = 2,
	FW_BACK_COL = 13*16+0
]
[
	FW_LAST_STATE = 32
]

var fragSorted[FW_NUM_FRAGMENTS]=0x84 ?, fragXPos[FW_NUM_FRAGMENTS] ?;
var ZPValueEnable ?;	// constant filled with OBJ_ENABLE, needed for kernel
var rocketXPos ?, rocketXPosLo ?, rocketTTL ?, rocketLastYPos ?, fragTTLCounter ?;
var rocketSeed ?, fragSeed ?; // Number of current rocket/fragment block; to derive xPosAdd, yPos, max time to live etc. from
var fw_seed ?;
// tmp
var fwCurrLine ?, currFragIndex ?;
// +1 for both to represent virtual "end of table"
var fragYPos[FW_NUM_FRAGMENTS+1] ?, fragSanitizedSorted[FW_NUM_FRAGMENTS+1] ?;
var fragCol[FW_NUM_FRAGMENTS] ?;
var rocketYPos ?; 
var fw_varend ?;
// Set address equal to fragYPos
var fwPtr_1[2]=0xd0, fwPtr_2[2], fwPtr_3[2], fwPtr_4[2], fwPtr_5[2], fwPtr_6[2];


/* Empty sl12 func
 */
func fw_sl12 {
}


/* Waste x lines.
 */
func fw_waste_lines {
	{wsync x--}!=
}


/* Fine-position object.
 * Pos in a, index in x. No hmove done.
 */
func fw_pos_object {
	wsync fw_sl12 c+ nocross{a-15}>= RESP0+256,x=a
	a^7 a<< a<< a<< a<< HMP0,x=a
}


/* pRNG
 */
func fw_rng {
		==goto .fw_doEor
		a<< ==goto .fw_noEor <goto .fw_noEor
.fw_doEor:
		a^0x1d
.fw_noEor:
}


/* inline pRNG
 */
inline fw_inline_rng {
		==goto .fw_doEor
		a<< ==goto .fw_noEor <goto .fw_noEor
.fw_doEor:
		a^0x1d
.fw_noEor:
}


/* One pass bubble sort for fragments
 */
func fw_sort_fragments {
	x=[FW_NUM_FRAGMENTS-1] {
		y=fragSorted,x a=fragYPos,y
		y=fragSorted-1,x a?fragYPos,y >={
			fragSorted-1,x=a=fragSorted,x
			fragSorted,x=y
		}
		x--
	}!=
}


/* Copy and sanitize fragments into fragSanitizedSorted
 */
func fw_sanitize_fragments {
	fragSanitizedSorted=x=fragSorted	// first entry is known already
	tmp2=a=fragYPos,x	// current min
	tmp=x=1 {		// current tail of sanitized list
		y=fragSorted,x a=fragYPos,y a?tmp2 <{
			// add star
			tmp2=a
			a=y y=tmp fragSanitizedSorted,y=a
			tmp++
		}
		x++ x?[FW_NUM_FRAGMENTS]
	}!=
	x=tmp fragSanitizedSorted,x=a=[FW_NUM_FRAGMENTS]	// set end of list
}


/* Kernel: display fragments
 * IN: rocketYPos
 */ 
func fw_display_fragments {
	wsync hmove
	COLUBK=COLUP0=COLUP1=a=tmp

	fwCurrLine=a=71
	COLUPF=a=0x08		// rocket color
	currFragIndex=a=0

	// Enter with a=0
	// Display M0, prepare M1
.displayM0:
	wsync hmove
	ENAM1=y=0 GRP0=a ENAM0=a=[OBJ_ENABLE]
	
	// Test for rocket (ball) display
	//a=[FR_ROCKET_HEIGHT]	// is OBJ_ENABLE
	nocross {
		a?--rocketYPos >=goto .drawRocketM0
		data {0x2c}
.drawRocketM0:
		y=ZPValueEnable		// potentially skipped by 0x2c "bit nn nn"
	}
	ENABL=y
	
	// Test for fragment display
	a=fwCurrLine y=currFragIndex x=fragSanitizedSorted,y a?fragYPos,x !=goto .noFragM0
	// Display fragment
	currFragIndex++
	COLUP1=a=fragCol,x
	y=fragXPos,x HMM1=a=fwHMoveTable,y
	HMM0=a=0 hmove GRP0=a sl3
	fwCurrLine--
	x=fwDelayTable,y
	nocross{x--}!= RESM1=a

	// Display M1, prepare M0
.displayM1:
	wsync hmove
	ENAM0=y=0 GRP1=a ENAM1=a=[OBJ_ENABLE]
	
	// Test for rocket (ball) display
	//a=[FR_ROCKET_HEIGHT]	// is OBJ_ENABLE
	nocross {
		a?--rocketYPos >=goto .drawRocketM1
		data {0x2c}
.drawRocketM1:
		y=ZPValueEnable		// potentially skipped by 0x2c "bit nn nn"
	}
	ENABL=y
	
	// Test for fragment display
	a=fwCurrLine y=currFragIndex x=fragSanitizedSorted,y a?fragYPos,x !=goto .noFragM1
	// Display fragment
	currFragIndex++
	COLUP0=a=fragCol,x
	y=fragXPos,x HMM0=a=fwHMoveTable,y
	HMM1=a=0 hmove GRP1+256=a
	fwCurrLine-- <0goto .afterDisplay	
	x=fwDelayTable,y
	nocross{x--}!= RESM0=a
	goto .displayM0

.noFragM0:
	HMM0=a=0
	wsync hmove GRP0=a
	RESM1=a
	COLUP1=a=0x08	// star color
	fwCurrLine--
	x=fwCurrLine a=fw_stars,x
	goto .displayM1

.noFragM1:
	HMM1=a=0
	wsync hmove GRP1=a
	RESM0=a
	COLUP0=a=0x0c	// star color
	fwCurrLine-- <0goto .afterDisplay
	x=fwCurrLine a=fw_stars,x
	goto .displayM0

.afterDisplay:
	ENAM0=ENAM1=GRP0=GRP1=ENABL=a=0
}


/* Display sunset and hills
 */
func fw_display_hills {
	COLUPF=a=0x02
	x=33 nocross {
		wsync hmove
		COLUBK=a=sunset_cols,x
		PF0=a=hills_1,x PF1=a=hills_2,x PF2=a=hills_3,x
		PF0=a=hills_4,x
		sl2
		PF1=a=hills_5,x
		sl3
		PF2=a=hills_6,x
		x--
	}>=0
	wsync hmove PF0=PF1=PF2=a=0 COLUBK=a=0x02
}


/* Display text
 */
func fw_display_text {
	wsync hmove
	
	// calc text address
	y=demoState y?25 >={y=0} x=divBy3,y !=goto .reallyText
	// No text: skip display
	x=33 goto .wasteBar
	
	// Really display text
.reallyText:
	
	wsync hmove
	a=FWTextPtrHi,x
	fwPtr_1+1=a
	fwPtr_2+1=a
	fwPtr_3+1=a
	fwPtr_4+1=a
	fwPtr_5+1=a
	fwPtr_6+1=a
	a=FWTextPtrLo,x
	// KK is special case b/c 4 rows are 0
	x?2 !=goto .notKK
	fwPtr_1=a
	fwPtr_2=a
	fwPtr_5=a
	fwPtr_6=a
	c- a+16	fwPtr_3=a
	a+16 fwPtr_4=a
	goto .prepare

.notKK:
	c-
	fwPtr_1=a a+16
	fwPtr_2=a a+16
	fwPtr_3=a a+16
	fwPtr_4=a a+16
	fwPtr_5=a a+16
	fwPtr_6=a
	
.prepare:
	// prepare sprites
	wsync
	hmove											// 3
	fw_sl12 sl10
	NUSIZ0=NUSIZ1=a=[THREE_COPIES_CLOSE]			// 8
	VDELP0=VDELP1=a=[VDEL_ENABLE]					// 8
	HMP0=a=[HM_NO_MOTION] HMP1=a=[HM_LEFT_1]		// 10
	// @51
	RESP0=a RESP1=a
	wsync hmove
	// calc color
	a=numFrame a>> a>> a?3 <{
		a<< tmp=a a=0x3a c+ a-tmp
	} else {
		a=0x36
	}
	COLUP0=COLUP1=a
	*2 HMCLR=a
	
	// display sprite
	tmp=a=15 wsync nocross {
		hmove														// 3
		sl5															// 5
		y=tmp														// 3
		GRP0=a=(fwPtr_1),y GRP1=a=(fwPtr_2),y GRP0=a=(fwPtr_3),y	// 24
		tmp2=a=(fwPtr_6),y a=x=(fwPtr_5),y a=(fwPtr_4),y y=tmp2		// 21
		// @56
		GRP1=a GRP0=x GRP1=y GRP0=a									// 12
		tmp--														// 5
	}>=0															// 3
	
	HMOVE+256=a
	VDELP0=VDELP1=a=0
	GRP0=GRP1=GRP0=a
	x=13 {
.wasteBar:
		wsync hmove
		x--
	}>=0
}


/* Init new rocket
 * Start x: 59...89, i.e. 59+0..31
 */
func fw_init_rocket {
	// set x pos: 46+0..63
	a=fw_seed fw_rng fw_seed=a a&63 c- a+46 rocketXPos=a
	// Restart time to live
	rocketTTL=a=0
}


/* Advance rocket and fragments
 * Re-uses tmp, tmp2, fwCurrLine, currFragIndex, fragSanitizedSorted
 */
func fw_advance {
	a=rocketTTL <0goto .fw_fragments
	
	/* Advance rocket */
	// Check TTL
	a=rocketSeed fw_rng a&31 c- a+25 tmp=a	// tmp = rocket TTL
	rocketTTL++ x=rocketTTL x?tmp =={
		// Increase state
		demoState++ numFrame=a=0
		// Get y pos for rocket before disabling.
		// Invert b/c fragment coordinate system is mirrored for y
		a=74 c+ a-fw_parabola,x rocketLastYPos=a y=a
		a=rocketXPos
		// Init fragments
		x=[FW_NUM_FRAGMENTS-1] {
			fragXPos,x=a
			x--
		}>=0
		// disable rocket
		rocketTTL=x
		// Init TTL counter and seed
		fragTTLCounter=a=0
		a=fw_seed fw_rng fw_seed=a fragSeed=a
	} else {
		// y
		x=rocketTTL rocketYPos=a=fw_parabola,x
		// x
		a=rocketSeed fw_rng tmp=a a&127 tmp2=a
		a=rocketXPosLo c- a+tmp2 rocketXPosLo=a >={
			// Move rocket left or right?
			a=tmp <0{
				rocketXPos++
			} else {
				rocketXPos--
			}
		}
	}
	
	/* Advance fragments */
.fw_fragments:
	// Fragments disabled?
	a=fragTTLCounter a?255 =={goto .end}
	
	// Do we have to disable rocket for this frame?
	a=rocketTTL a?255 =={
		rocketYPos=a=0
	}
	// Advance fragments
	fragTTLCounter++
	// calc color scheme
	a=fragSeed a&7 a<< currFragIndex=a a<< a<< a<< c- a+currFragIndex currFragIndex=a
	// xpos, ypos, color, TTL
	a=fragTTLCounter a&15 tmp=a	// ttlCounter&15 (for 16 different speeds)
	// reuse fwCurrLine for seed, for x speeds and TTL
	x=fragSeed x++ fwCurrLine=x // x++ so prngs are different streaks for each rocket, not only shifted by one
	a=fragTTLCounter c- a+44 tmp2=a // 44: start index of parabola for fragments
	x=[FW_NUM_FRAGMENTS-1] {
		// Advance frag pRNG
		a=fwCurrLine fw_inline_rng fwCurrLine=a
		// Check TTL (40+0..31)
		a&31 c- a+40 a?fragTTLCounter <{
			fragYPos,x=a=0
		} else {
			// color
			// maxTTl-current /8 is index lo
			c+ a-fragTTLCounter a>> a>> a>> fragSanitizedSorted=a			
			// calc color table base
			a=x c- a+currFragIndex y=a a=frag_col_combos,y
			// add lo to base
			c- a+fragSanitizedSorted y=a
			fragCol,x=a=frag_colors,y

			// x: alternate between left/right according to index bit #0
			// rocket rng is base index into xspeed table (0..7 *16), + ttlCounter&15
			a=fwCurrLine a&0b01110000 c- a+tmp y=a
			a=x a&1 =={
				// carry is clear already
				a=fragXPos,x a+frag_xspeeds,y fragXPos,x=a
			} else {
				a=fragXPos,x c+ a-frag_xspeeds,y fragXPos,x=a
			}

			// y: rocketLastYPos + offsetByIndex - parabola
			a=fw_frag_yoffsets,x c- a+rocketLastYPos	// lastY + offset
			y=tmp2 c+ a-fw_parabola,y					// - parabola
			a?71 >={a=0}
			fragYPos,x=a
		}
		a=tmp2 c- a+4 tmp2=a
		x--
	}>=0
	
	// Check if we need to start a new rocket
	a=fragTTLCounter a?40 =={
		a=demoState a?[FW_LAST_STATE-2] <{
			a=rocketSeed fw_rng rocketSeed=a
			fw_init_rocket
		}
	}
	// Check if we need to disable fragments
	a=fragTTLCounter a?80 =={
		fragTTLCounter=a=255
	}

.end:
}


/* Entry point
 */
func fw_main {
	// Init
	s=x=0xff

	CTRLPF=a=0
	fw_seed=a
	rocketSeed=a

	PF0=PF1=PF2=a

	demoState=a numFrame=a=10


	// Init sorted index array
	x=[FW_NUM_FRAGMENTS-1] {
		a=x fragSorted,x=a
		x--
	}>=0
	// Init rest of vars
	ZPValueEnable=a=[OBJ_ENABLE]
	fragTTLCounter=a=255
	fragYPos+[FW_NUM_FRAGMENTS]=a
	fw_init_rocket
	goto FireworksStart

	// Kernel
	{
		/**************************************************
		 * Overscan
		 **************************************************/
		
		overscan_start
		
FireworksStart:

		// Script
		numFrame++
		
		a=demoState ==goto .noAdvance
		a?[FW_LAST_STATE-2] =={
			rocketYPos=a=0
			a=numFrame a?150 =={
				demoState++ numFrame=a=10
			}
			goto .advance
		}
		a?[FW_LAST_STATE-1] >=goto .noAdvance
		
.advance:
		fw_advance
		goto .afterAdvance

.noAdvance:
		rocketYPos=a=0
		a=numFrame a?100 =={
			numFrame=a=10 demoState++	// 10 so no initial flash occurs
.die:			a=demoState a?[FW_LAST_STATE] ==goto .die
		}

.afterAdvance:
		nocross {overscan_end}

		/**************************************************
		 * VBlank
		 **************************************************/
		
		vblank_start
		
		NUSIZ0=NUSIZ1=VDELP0=VDELP1=a=0
		// Position rocket and star player
		a=rocketXPos x=4 fw_pos_object wsync hmove
		RESM0=RESM1=a
		fw_sl12 fw_sl12 RESP0=RESP1=a HMBL=a=0
		HMP0=a=[HM_LEFT_7] HMP1=a=[HM_RIGHT_7]
		
		// Do an odd number of calls to make sure fragments on same line flicker
		fw_sort_fragments
		fw_sort_fragments
		fw_sort_fragments

		fw_sanitize_fragments

		// Calc screen (flash) color
		a=numFrame a>> x=a x?5 >={x=5} a=FW_flashcols,x
		tmp=a
		COLUBK=COLUP0=COLUP1=a=0

		far music

		nocross{vblank_end}
		
		/**************************************************
		 * Visible screen
		 **************************************************/

		screen_start
		
		fw_display_fragments

		fw_display_hills
		
		fw_display_text
		
		screen_end

	} always
}
