/*
 * OPTIMIZE:
 * - Speed: unpacking (,x not needed for m0/m1)
 * - RAM: re-order so that m0/m1 params not written to by unpack are used for incoming
 */



var cube_activeObjects=0x84;
var cube_m0_xLo ?, cube_m0_xAddLo ?, cube_m0_xAdd ?, cube_m0_xAddPlus1 ?, cube_m0_dy ?, cube_m0_count ?, cube_m0_repos ?;
var cube_m1_xLo ?, cube_m1_xAddLo ?, cube_m1_xAdd ?, cube_m1_xAddPlus1 ?, cube_m1_dy ?, cube_m1_count ?, cube_m1_repos ?;
// Here packed frame data buffer starts
var cube_M0XPos ?, cube_M0YPos=0x94 ?,
	cube_P0XPos ?, cube_P0YPos ?, cube_P1XPos ?, cube_P1YPos ?;
var cube_p0_xLo ?, cube_p0_xAddLo ?, cube_p0_xAdd ?, cube_p0_xAddPlus1 ?, cube_p0_dy ?, cube_p0_count ?, cube_p0_repos ?;
var cube_p1_xLo ?, cube_p1_xAddLo ?, cube_p1_xAdd ?, cube_p1_xAddPlus1 ?, cube_p1_dy ?, cube_p1_count ?, cube_p1_repos ?;
// Rest of incoming buffer depending on max size of frame
// Since first bytes get unpacked into m0/m1 vars, a bit of overlap with
// bytecode is ok.
// CUrrent max frame size:	48
// cubeM0XPos+:				 6
// m0/m1:					 6+
// p0/p1 params:			14
var cube_incoming[22] ?;
var cube_byteCode[50] ?;
var cube_varend ?;


/* Waste x scanlines.
 */
func cube_waste {
	{wsync x--}!=
}


/* Empty, dummy display kernel
 */
func cube_sl12 {
}


/* Fine-position object.
 * a: position (0..159)
 * x: object number
 * Does not do the necessary HMOVE, only prepares HM register.
 */
func cube_pos_object {
	wsync cube_sl12 *2 c+ nocross{a-15}>= RESP0,x=a
	a^7 a<< a<< a<< a<< HMP0,x=a
}



/* Prepare and position objects for lines kernel.
 */
func cube_prepare_objects {
	// Position objects
	NUSIZ0=NUSIZ1=x=0
	a=cube_P0XPos cube_pos_object
	x++ a=cube_P1XPos cube_pos_object
	x++ a=cube_M0XPos cube_pos_object
	x++ a=cube_M0XPos cube_pos_object
	wsync hmove
	// Init number of objects
	x=4 a=cube_P1XPos =={x--} a=cube_P0XPos =={x--} cube_activeObjects=x
	
	// Calc player distances from top m0 point
	a=cube_P0YPos c+ a-cube_M0YPos	// cannot be 0 (sanitized)
	cube_p0_count=a
	a=cube_P1YPos c+ a-cube_M0YPos	// cannot be 0 (sanitized)
	cube_p1_count=a
	// Set initial NUSIZ
	NUSIZ0=a=cube_m0_xLo NUSIZ1=a=cube_m1_xLo
	// Reset HM regs
	HMCLR=a
	
	// Init kernel vars
	cube_m0_xLo=cube_m1_xLo=a=0
	cube_p0_xAddLo=a cube_p0_repos=a cube_p0_xAdd=a
	cube_p1_xAddLo=a cube_p1_repos=a cube_p1_xAdd=a
}



func cube_kernel {
	// Waste lines depending on top point
	x=cube_M0YPos x++ cube_waste

	// Prepare stack pointer
	tmp=x=s s=x=&<cube_byteCode-1
	
	// Start kernel by enabling all objects
	y=0
	wsync ENAM0=ENAM1=a=[OBJ_ENABLE]
	{
		////////// M0 ////////////////////////////////////////
		// Do movement
		a=cube_m0_xLo c+ a-cube_m0_xAddLo
		// Check for underflow and set x to xAdd/xAddPlus1 accordingly
		x=cube_m0_xAdd <{ a+cube_m0_dy x=cube_m0_xAddPlus1 }
		cube_m0_xLo=a HMM0=x
		// Do potential new line
		cube_m0_count-- =={
			// New line: check if we have to reposition first
			a=cube_m0_repos !={
				wsync cube_sl12 *3 c+ nocross{a-15}>= RESM0=a	// fine-pos
				a^7 a<< a<< a<< a<< HMM0=a
				cube_m0_repos=y
			}
			// Process byte code for new line
			a?? == {
				// End of lines for this object: Disable
				cube_m0_xAddLo=ENAM0=a
				cube_activeObjects--
			} else {
				// Prepare new line
				cube_m0_xAdd=a a<< a<< a<< a<< cube_m0_xAddPlus1=a	// xAddHi
				a?? cube_m0_xAddLo=a								// xAddLo
				a??	<0{										// dy, maybe reposition
					a&0b01111111 cube_m0_dy=cube_m0_count=a			// mask re-pos bit to get real dy
					a?? cube_m0_repos=a !=goto .m0Size			// get and store new xpos, for next node
				}
				cube_m0_dy=cube_m0_count=a
.m0Size:
				a?? NUSIZ0=a								// size
				cube_m0_xLo=y
			}
		}

		////////// M1 ////////////////////////////////////////
		// Do movement
		a=cube_m1_xLo c+ a-cube_m1_xAddLo
		// Check for underflow and set x to xAdd/xAddPlus1 accordingly
		x=cube_m1_xAdd <{ a+cube_m1_dy x=cube_m1_xAddPlus1 }
		cube_m1_xLo=a HMM1=x
		// Do potential new line
		cube_m1_count-- =={
			// New line: check if we have to reposition first
			a=cube_m1_repos !={
				wsync cube_sl12 *3 c+ nocross{a-15}>= RESM1=a	// fine-pos
				a^7 a<< a<< a<< a<< HMM1=a
				cube_m1_repos=y
			}
			// Process byte code for new line
			a?? == {
				// End of lines for this object: Disable
				cube_m1_xAddLo=ENAM1=a
				cube_activeObjects--
			} else {
				// Prepare new line
				cube_m1_xAdd=a a<< a<< a<< a<< cube_m1_xAddPlus1=a	// xAddHi
				a?? cube_m1_xAddLo=a								// xAddLo
				a??	<0{										// dy, maybe reposition
					a&0b01111111 cube_m1_dy=cube_m1_count=a			// mask repos bit to get real dy
					a?? cube_m1_repos=a !=goto .m1Size			// get and store new xpos, for next node
				}
				cube_m1_dy=cube_m1_count=a
.m1Size:
				a?? NUSIZ1=a								// size
				cube_m1_xLo=y
			}
		}

		////////// P0 ////////////////////////////////////////
		// Do movement
		a=cube_p0_xLo c+ a-cube_p0_xAddLo
		// Check for underflow and set x to xAdd/xAddPlus1 accordingly
		x=cube_p0_xAdd <{ a+cube_p0_dy x=cube_p0_xAddPlus1 }
		cube_p0_xLo=a HMP0=x
		// Do potential new line
		cube_p0_count-- =={
			// New line: check if we have to reposition first
			a=cube_p0_repos !={
				wsync cube_sl12 *3 c+ nocross{a-15}>= RESP0=a	// fine-pos
				a^7 a<< a<< a<< a<< HMP0=a
				cube_p0_repos=y
			}
			// Process byte code for new line
			a?? == {
				// End of lines for this object: Disable
				cube_p0_xAddLo=GRP0=a
				cube_activeObjects--
			} else {
				// Prepare new line
				cube_p0_xAdd=a a<< a<< a<< a<< cube_p0_xAddPlus1=a	// xAddHi
				a?? cube_p0_xAddLo=a								// xAddLo
				a??	<0{										// dy, maybe reposition
					a&0b01111111 cube_p0_dy=cube_p0_count=a			// mask repos bit to get real dy
					a?? cube_p0_repos=a !=goto .p0Size			// get and store new xpos, for next node
				}
				cube_p0_dy=cube_p0_count=a
.p0Size:
				a?? GRP0=a									// size
				cube_p0_xLo=y
			}
		}

		////////// P1 ////////////////////////////////////////
		// Do movement
		a=cube_p1_xLo c+ a-cube_p1_xAddLo
		// Check for underflow and set x to xAdd/xAddPlus1 accordingly
		x=cube_p1_xAdd <{ a+cube_p1_dy x=cube_p1_xAddPlus1 }
		cube_p1_xLo=a HMP1=x
		// Do potential new line
		cube_p1_count-- =={
			// New line: check if we have to reposition first
			a=cube_p1_repos !={
				wsync cube_sl12 *3 c+ nocross{a-15}>= RESP1=a	// fine-pos
				a^7 a<< a<< a<< a<< HMP1=a
				cube_p1_repos=y
			}
			// Process byte code for new line
			a?? == {
				// End of lines for this object: Disable
				cube_p1_xAddLo=GRP1=a
				cube_activeObjects--
			} else {
				// Prepare new line
				cube_p1_xAdd=a a<< a<< a<< a<< cube_p1_xAddPlus1=a	// xAddHi
				a?? cube_p1_xAddLo=a								// xAddLo
				a??	<0{										// dy, maybe reposition
					a&0b01111111 cube_p1_dy=cube_p1_count=a			// mask repos bit to get real dy
					a?? cube_p1_repos=a !=goto .p1Size			// get and store new xpos, for next node
				}
				cube_p1_dy=cube_p1_count=a
.p1Size:
				a?? GRP1=a							// size
				cube_p1_xLo=y
			}
		}


		// For all objects: hmove, then loop
		wsync hmove
		a=cube_activeObjects =={goto .AfterLinesKernel}
	}always
	
.AfterLinesKernel:
	wsync ENAM0=ENAM1=GRP0=GRP1=y

	// Restore stack pointer
	s=x=tmp
}


/* Unpack frame data.
 * IN: cube_activeObjects: size
 */
func cube_unpack {
	// x is index for src, y for dst
	// First six bytes don't need to be unpacked
	x=6 y=0
	
	// Manually unpack M0 directly into vars (no y index needed)
	// xAdd/xAddPlus1
	a=cube_M0XPos,x a&15 tmp=x x=a a=cube_hmtable,x x=tmp
	cube_m0_xAdd=a a<< a<< a<< a<< cube_m0_xAddPlus1=a
	// Size: Use m0_xLo for NUSIZ tmp store
	a=cube_M0XPos,x a>> a>> a>> a>> tmp=x x=a a=cube_sizetable,x x=tmp cube_m0_xLo=a
	// xAddLo
	cube_m0_xAddLo=a=cube_M0XPos+1,x
	// dy and potential repos
	a=cube_M0XPos+2,x <0{
		// Repos
		a&0b01111111 cube_m0_dy=cube_m0_count=a
		a=cube_M0XPos+3,x x++ cube_m0_repos=a
	} else {
		cube_m0_dy=cube_m0_count=a
	}
	x++ x++ x++
	
	// Manually unpack M1 directly into vars (no y index needed)
	// xAdd/xAddPlus1
	a=cube_M0XPos,x a&15 tmp=x x=a a=cube_hmtable,x x=tmp
	cube_m1_xAdd=a a<< a<< a<< a<< cube_m1_xAddPlus1=a
	// Size: Use m1_xLo for NUSIZ tmp store
	a=cube_M0XPos,x a>> a>> a>> a>> tmp=x x=a a=cube_sizetable,x x=tmp cube_m1_xLo=a
	// xAddLo
	cube_m1_xAddLo=a=cube_M0XPos+1,x
	// dy and potential repos
	a=cube_M0XPos+2,x <0{
		// Repos
		a&0b01111111 cube_m1_dy=cube_m1_count=a
		a=cube_M0XPos+3,x x++ cube_m1_repos=a
	} else {
		cube_m1_dy=cube_m1_count=a
	}
	x++ x++ x++
	
	// Unpack rest
	{
		// xAdd/xAddPlus1 or end line
		a=cube_M0XPos,x !=goto .notEndLine
		// emit "terminate line" zero
		cube_byteCode,y=a y++ x++
		goto .checkForEnd
.notEndLine:
		a&15 tmp=x x=a cube_byteCode,y=a=cube_hmtable,x x=tmp y++
		// xAddLo
		cube_byteCode,y=a=cube_M0XPos+1,x y++
		// dy and potential repos
		a=cube_M0XPos+2,x <0{
			// Repos
			a&0b01111111 cube_byteCode,y=a y++
			cube_byteCode,y=a=cube_M0XPos+3,x y++
			// Preload size
			a=cube_M0XPos,x x++
		} else {
			cube_byteCode,y=a y++
			// Preload size
			a=cube_M0XPos,x
		}
		// size
		a>> a>> a>> a>> tmp=x x=a cube_byteCode,y=a=cube_sizetable,x x=tmp y++
		x++ x++ x++
.checkForEnd:
		x?cube_activeObjects
	}!=
	
	// Put extra "terminate line" zeros at end
	a=0 cube_byteCode,y=a cube_byteCode+1,y=a cube_byteCode+2,y=a cube_byteCode+3,y=a
}

// Size tables. First P, then M
data cube_sizetable {
	0b10000000 0b10000000 0b11000000 0b11100000 0b11110000 0b11111000 0b11111100 0b11111110
	0b00000000 0b00000000 0b00010000 0b00010000 0b00100000 0b00100000 0b00100000 0b00100000
}
// HM tables. First left, then right
data cube_hmtable {
	0x01 0x12 0x23 0x34 0x45 0x56 0x67 0x67
	0x0f 0xfe 0xed 0xdc 0xcb 0xba 0xa9 0x98
}



/* Main
 */
func cube_main {
	s=x=0xff

	// Position ball for hmove bar hiding
	wsync RESBL=a CTRLPF=a=[BALL_SIZE_8]
	// Init
	a=0
	demoState=a numFrame=a
	COLUPF=PF0=PF1=PF2=ENAM0=ENAM1=a
	HMBL=a=[HM_LEFT_2] wsync hmove
	!=goto CubeStart

	// Kernel
	{
		/**************************************************
		 * Overscan
		 **************************************************/
		
		overscan_start

CubeStart:

		// Script
		numFrame++
		x=demoState a=cube_durations,x !={
			a?numFrame =={
				numFrame=a=0 demoState++
				a=demoState a?[STATES_CUBE_END] =={far fw_main}
			}
		}
		
		ENABL=a=[OBJ_ENABLE]

		// Fetch frame to display
		a=demoState
		a?[STATES_CUBE_FIRST] !=goto .notFirst
		x=2 !=goto .fetch
.notFirst:
		a?[STATES_CUBE_SECOND] !=goto .notSecond
		x=1 !=goto .fetch
.notSecond:
		a?[STATES_CUBE_THIRD] !=goto .notThird
		x=0 !=goto .fetch
.notThird:
		a?[STATES_CUBE_FOURTH] !=goto .notFourth
		x=2 !=goto .fetch
.notFourth:
		a?[STATES_CUBE_BEFOREROTATE] !=goto .notBefore
		x=0 !=goto .fetch
.notBefore:
		// Rotate!
		a=numFrame a>> a&63 x=a
		// REMOVEME
		x=2

.fetch:
		far cube_fetch_ptr
		cube_activeObjects=y
		far cube_fetch_frame

		far music

		overscan_end


		/**************************************************
		 * VBlank
		 **************************************************/
		
		vblank_start

		cube_unpack
		cube_prepare_objects

		COLUBK=a=0x72
		COLUP0=COLUP1=a=0x7e
		a=demoState a?[STATES_CUBE_CONVINCED] >={
			a=numFrame a>> a>> a&7 x=a
			COLUP0=COLUP1=a=cube_flash,x
		}

		vblank_end

		
		/**************************************************
		 * Visible screen
		 **************************************************/
		
		x=20 cube_waste
		COLUBK=a=0x0a wsync
		COLUBK=a=0xb0
		TIM64T=a=207
		
		// Multiplex display kernel
		wsync
		a=demoState
		a?[STATES_CUBE_NOTHING] ==goto CubeEndOfKernel
		a?[STATES_CUBE_THEY] ==goto .text
		a?[STATES_CUBE_CANNOT] ==goto .text
		a?[STATES_CUBE_STOCK] ==goto .text
		a?[STATES_CUBE_CONVINCED] !=goto displayCube

.text:
		x=55 cube_waste
		far cube_text
		goto CubeEndOfKernel
		
displayCube:
		// display cube
		wsync
		cube_kernel

CubeEndOfKernel:		
		timwait
		wsync COLUBK=a=0x0a wsync
		COLUBK=a=0x72
		x=20 cube_waste
		
	} always
	
}

data cube_durations {
	100	// STATES_CUBE_NOTHING = 0
	60	// STATES_CUBE_FIRST = 1,
	130	// STATES_CUBE_THEY = 2,
	60	// STATES_CUBE_SECOND = 3,
	130	// STATES_CUBE_CANNOT = 4,
	60	// STATES_CUBE_THIRD = 5,
	130	// STATES_CUBE_STOCK = 6,
	60	// STATES_CUBE_FOURTH = 7,
	200	// STATES_CUBE_CONVINCED = 8,
	60	// STATES_CUBE_BEFOREROTATE = 9,
	255	// STATES_CUBE_ROTATE = 10,
	255	// 11
	255	// 12
	255	// 13
	//STATES_CUBE_END = 14
}

data cube_flash {
	0x78 0x7a 0x7c 0x7e 0x0e 0x7e 0x7c 0x7a
}
